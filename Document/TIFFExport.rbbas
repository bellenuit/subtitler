#tag ClassProtected Class TIFFExport	#tag Method, Flags = &h0		Sub Constructor(path as string)		  f = getfolderitem(path)		  compression = 1		  top = 0		  left = 0		  bottom = 0		  right = 0		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub packbits2(b as binarystream, m as binarystream, s as integer)		  		  //Loop until you get the number of unpacked bytes you are expecting:		  //  Read the next source byte into n.		  //  If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.		   // Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.		   //Else if n is -128, noop.		  // Endloop		  		  //-127 is 129		  		  dim i as integer		  dim count as integer		  dim test,old,oldold as integer		  dim st as string		  dim run as boolean		  		  //test with declare		  		  		  'dim memIn,memOut  as memoryblock		  '		  'if s = 0 then		  'return		  'end		  '		  'memIn = newmemoryBlock(s)		  'for i = 0 to s-1		  'memin.byte(i) = m.readbyte		  'next		  'memOut = newmemoryBlock(s+(s+126)/127)		  '		  'Declare Sub PackBits Lib "InterfaceLib" (srcPtr as Ptr, dstPtr as Ptr, srcBytes as Integer)		  '		  'PackBits memIn,memOut,s		  '		  'for i = 0 to s+(s+126)/127-1		  '		  'next		  '		  'return		  		  test=-1		  old = -1		  oldold=-1		  count = -1		  run = false		  st=""		  for i = 0 to s-1		    test = m.readbyte		    if run then		      if test = old then		        count = count -1		        if count = 129  then		          b.writebyte count		          b.writebyte test		          run = false		          test = -1		          count = -1		          st = ""		        end if		      else		        b.writebyte count		        b.writebyte old		        run = false		        count = 0		        st =chr(test)		      end if		    else		      if test = old and test = oldold then		        if count > 1 then		          b.writebyte count-2		          b.write st		          b.position = b.position -2		        end if		        run = true		        count = 254		        st =""		      else		        st = st + chr(test)		        count = count + 1		        if count = 127 then		          b.writebyte count		          b.write st		          run = false		          test = -1		          count = -1		          st = ""		        end if		      end if		    end if		    oldold = old		    old = test		    		  next		  if count >-1 then		    if run then		      b.writebyte count		      b.writebyte test		    else		      b.writebyte count		      b.write st		    end if		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub PBWriteBlack(b as binarystream, s as integer)		  if defaultwhite then		    PBWriteBlack(b,s,255)		  else		    PBWriteBlack(b,s,0)		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub PBWriteBlack(b as binarystream, s as integer, v as integer)		  dim i as integer		  for i = 1 to s\128		    b.writebyte 129		    b.writebyte v		  next		  if s mod 128 > 0 then		    if s mod 128 > 1 then		      b.writebyte 257 - (s mod 128)		      b.writebyte v		    elseif s mod 128 = 1 then		      b.writebyte 0		      b.writebyte v		    else		    end if		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsBMP8(pict as picture)		  dim b as binarystream		  dim i,j,k, fullcount, restcount as integer		  dim strip,nstripes as integer		  dim start, pos , channels, file as integer		  dim g,h as rgbsurface		  dim c,a as color		  dim noalpha as boolean		  dim fpos,opos,spos,oldfpos , rowstart as integer		  dim pack as boolean		  dim bounding as boolean		  dim s as string		  dim counttags as integer		  dim vol as folderitem		  dim mem,mem2 as memoryBlock		  dim memoffset as integer		  dim blackstripstart, blackstriplength as integer		  dim filesize,bmpstart as integer		  		  		  'app.consolelog "saveastiff bounds " + str(left) + " " + str(top) + " " +str(right) + " " + str(bottom)		  		  #pragma disablebackgroundtasks		  		  bounding = not( (top=0) or (left=0) or (bottom=0) or (right = 0))		  		  b = f.createBinaryFile("image/x-bmp") // define filetype BMP		  		  if b = nil then		    msgBox "Could not create file " + f.name + endofLine + endofLine _		    + "A file with the same name may be used by another application."		    // why? should be an error.		    return		  end if		  		  b.littleEndian = true // !!		  b.position = 0		  		  // write header 14 bytes		  b.write "BM"  //0		  b.writelong filesize // 2 to be written again at the end		  b.writeshort 0 // 6 reserved		  b.writeshort 0 // 8 reserved		  b.writelong bmpstart // 10, to be written again later		  		  //write BitmapInfoHeader 28 bytes		  b.writelong 40 // 14, bisize		  b.writelong pict.width  //18		  b.writelong pict.height  // 22		  b.writeshort 1 // planes  26		  b.writeshort 8 // bit count   28		  b.writelong 1 // BI_RLE8 compression  30		  b.writelong pict.width*pict.height // byte size of picture  34		  b.writelong 2835 //pixelspermeter  38		  b.writelong 2834 // v  42		  b.writelong 255 // colors used 46		  b.writelong 255 // colors important  50		  		  //write colortable		  b.writelong &hFFFFFF // white		  b.writelong &h00000 // black		  b.writelong &hFF0000 // red		  b.writelong &h0000FF // blue		  for i = 4 to 255		    b.writelong &h000000		  next		  		  bmpstart = b.position		  		  g = pict.rgbSurface		  		  for i =  pict.height-1 downto 0 // bottom top		    		    if userCancelled then		      b.close		      f.delete		      return		    end if		    fullcount = pict.width \ 255		    restcount = pict.width mod 255		    if bounding and (i<top or i>bottom) then		      // write white for width		      for j = 1 to fullcount		        b.writebyte &hFF  // 255 times		        b.writebyte &h00  // white		      next		      if restcount > 0 then		        b.writebyte restcount		        b.writebyte &h00		      end		    else		      for k = 0 to pict.width-1		        'if (k  mod 255 = 0) then		        'b.writebyte &h00		        'b.writebyte min(pict.width-k,255)		        'end		        b.writebyte 1		        c = g.Pixel(k,i)		        select case c		        case &cffffff		          b.writebyte 0		        case &c000000		          b.writebyte 1		        case &cff0000		          b.writebyte 2		        case &c0000ff		          b.writebyte 3		        else		          b.writebyte 0		        end		      next		    end if		    if i>0 then		      b.writebyte &h00 // escape		      b.writebyte &h00 // end of line		    else		      b.writebyte &h00 // escape		      b.writebyte &h01 // end of bitmap		    end		  next		  filesize = b.position		  b.position = 2		  b.writelong filesize		  b.position = 10		  b.writelong bmpstart		  b.close		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsPICT(pict as Picture, alpha as Picture)		  dim b as binarystream		  dim i,j,k as integer		  dim strip,nstripes as integer		  dim start, pos , channels as integer		  dim g,h as rgbsurface		  dim c,a as color		  dim noalpha as boolean		  dim fpos,opos,spos,oldfpos as integer		  dim pack as boolean		  dim bounding as boolean		  dim s as string		  dim m as binarystream		  dim counttags as integer		  dim vol, temp as folderitem		  dim sizepos, rowstart, rowend as integer		  		  bounding = not( (top=0) or (left=0) or (bottom=0) or (right = 0))		  		  if alpha = nil or alpha.width <> pict.width or alpha.height <> pict.height then		    noalpha = true		    channels = 3		  else		    noalpha = false		    channels = 4		  end if		  		  temp = volume(0).temporaryFolder.child("Subtitler TIFFExport")		  if temp.exists then		    m= temp.openasbinaryfile(true)		    m.littleEndian = false		  else		    m=temp.createbinaryFile("TEMP")		    m.littleEndian = false		  end if		  		  if m = nil then		    msgbox "Nil object Tempfile"		    return		  end if		  		  b = f.createBinaryFile("PICT") // define filetype PICT		  		  if b = nil then		    f.delete		    b  = f.createBinaryFile("PICT") 		    if b = nil then		      msgBox "Could not create file " + f.name + endofLine + endofLine _		      + "A file with the same name may be used by another application."		      // why? should be an error.		      		      'msgbox StNilObjectExportStream		      return		    end if		  end if		  b.littleEndian = false		  b.position = 0		  		  for i = 0 to &h1FF		    b.writebyte 0  //clear preheader part		  next		  		  sizepos = &h200		  		  //200		  b.writeshort 0  //will be size later		  		  //202  //frame 		  b.writeshort 0		  b.writeshort 0		  b.writeshort pict.height		  b.writeshort pict.width		  		  //20A //pict2		  b.writeshort &h0011		  b.writeshort &h02FF		  		  //20E header		  b.writeshort &h0C00		  		  //210 ??		  b.writeshort &hFFFE		  b.writeshort 0		  		  //214 hres		  b.writeshort &h0048		  b.writeshort 0		  		  //218 vres		  b.writeshort &h0048		  b.writeshort 0		  		  //21C pixeltype		  b.writeshort 0		  		  //21E pixelsize		  b.writeshort 0		  		  //220 ??		  b.writeshort pict.height		  b.writeshort pict.width		  b.writeshort 0		  b.writeshort 0		  b.writeshort &h0001		  b.writeshort &h000A		  b.writeshort 0		  b.writeshort 0		  		  //230		  b.writeshort pict.height		  b.writeshort pict.width		  b.writeshort &h009A		  b.writeshort 0		  b.writeshort &h00FF		  b.writeshort &h8B40		  b.writeshort 0		  b.writeshort 0		  		  //240		  b.writeshort pict.height		  b.writeshort pict.width		  b.writeshort 0		  b.writeshort &h0004		  b.writeshort 0		  b.writeshort 0		  		  //24C hres, vres		  b.writeshort &h0048		  b.writeshort 0		  b.writeshort &h0048		  b.writeshort 0		  		  b.writeshort &h0010		  b.writeshort &h0020		  		  //cmpcount		  b.writeshort channels		  //cmpsize		  b.writeshort &h0008		  //planebytes		  b.writeshort 0		  b.writeshort 0		  		  //260		  b.writeshort 0 //mystery		  b.writeshort 0 // mystery		  b.writeshort 0		  b.writeshort 0		  b.writeshort 0		  b.writeshort 0		  b.writeshort pict.height		  b.writeshort pict.width		  		  		  //270		  b.writeshort 0		  b.writeshort 0		  b.writeshort pict.height		  b.writeshort pict.width		  b.writeshort 0		  		  //preparing m		  for i = 0 to pict.width*channels -1		    m.writebyte 0		  next		  		  g = pict.rgbSurface		  if noalpha then		  else		    h = alpha.rgBSurface		  end if		  		  for i = 0 to pict.height-1		    		    if userCancelled then		      b.close		      m.close		      temp.delete		      f.delete		      return		    end if		    		    // writing fake count		    rowstart = b.position		    b.writeshort 0		    		    //writing image data		    		    if bounding and (i<top or i>bottom) then		      if  noalpha then		        pbwriteblack(b,3*pict.width,0)		      else		        pbwriteblack(b,4*pict.width,0)		      end if		    else		      m.position=0		      if not noalpha then		        for k = 0 to pict.width-1		          if bounding and (k<left or k>right) then		            m.writebyte 0		          else		            c = h.pixel(k,i)		            m.writebyte 255-c.green		          end		        next		      end		      for k = 0 to pict.width-1		        if bounding and (k<left or k>right) then		          m.writebyte 0		        else		          c = g.pixel(k,i)		          m.writebyte c.red		        end		      next		      for k = 0 to pict.width-1		        if bounding and (k<left or k>right) then		          m.writebyte 0		        else		          c = g.pixel(k,i)		          m.writebyte c.green		        end		      next		      for k = 0 to pict.width-1		        if bounding and (k<left or k>right) then		          m.writebyte 0		        else		          c = g.pixel(k,i)		          m.writebyte c.blue		        end		      next		      m.position = 0		      packbits2(b, m, channels*pict.width)		    end if		    rowend = b.position		    b.position = rowstart		    b.writeshort rowend-rowstart-2		    b.position = rowend		  next		  		  //get even end		  if b.position mod 2 = 1 then		    b.writebyte 0		  end		  		  //write end flag		  b.writeshort &h00FF		  		  //write size to pos 200		  rowend = b.position		  b.position = sizepos		  b.writeshort rowend-sizepos 		  m.close		  temp.delete		  b.close		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsPNG(pict as Picture, alpha as Picture)		  dim s as string		  dim b as binarystream		  		  //removed depency		  //s = PictureToPNGStringMBS(pict,alpha,0)		  dim m as MemoryBlock		  m = pict.GetData(Picture.FormatPNG,100)		  s = m.StringValue(0,m.size)		  // end		  		  if len(s) = 0 then		    MsgBox "Could not get PNG Data"		    return		  end		  		  b = f.CreateBinaryFile("image/PNG")		  if b=nil then		    msgBox "Could not create file " + f.name + endofLine + endofLine _		    + "A file with the same name may be used by another application."		    return		  else		    b.write s		    b.close		  end		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SaveAsTIFF(pict as picture, alpha as picture)		  dim b as binarystream		  dim i,j,k as integer		  dim strip,nstripes as integer		  dim start, pos , channels as integer		  dim g,h as rgbsurface		  dim c,a as color		  dim noalpha as boolean		  dim fpos,opos,spos,oldfpos , rowstart as integer		  dim pack as boolean		  dim bounding as boolean		  dim s as string		  dim counttags as integer		  dim vol as folderitem		  dim mem,mem2 as memoryBlock		  dim memoffset as integer		  dim blackstripstart, blackstriplength as integer		  		  		  'app.consolelog "saveastiff bounds " + str(left) + " " + str(top) + " " +str(right) + " " + str(bottom)		  		  #pragma disablebackgroundtasks		  		  bounding = not( (top=0) or (left=0) or (bottom=0) or (right = 0))		  		  if alpha = nil or alpha.width <> pict.width or alpha.height <> pict.height then		    noalpha = true		    channels = 3		  else		    noalpha = false		    channels = 4		  end if		  		  b = f.createBinaryFile("TIFF") // define filetype TIFF		  		  if b = nil then		    msgBox "Could not create file " + f.name + endofLine + endofLine _		    + "A file with the same name may be used by another application."		    // why? should be an error.		    return		  end if		  		  b.littleEndian = false		  b.position = 0		  		  for i = 0 to 288+8*pict.height		    b.writebyte 0  //clear header part		  next		  		  b.position = 0		  		  //0: header 8 byte		  b.writebyte asc("M") //big endian macintosh file type		  b.writebyte asc("M")		  b.writeshort 42  //this is a TIFF file number 42		  		  b.writelong 8              //offset of the first IFD		  		  		  //apple lion changes: it writes the following directory - to be detected		  		  // 00 10 		  // 01 00 00 03 00 00 00 01 02 D0 00 00  256 ImageWidth		  // 01 01 00 03 00 00 00 01 02 40 00 00  257ImageLength		  // 01 02 00 03 00 00 00 04 00 00 82 B2  258 BitsperSample		  // 01 03 00 03 00 00 00 01 80 05 00 00  259 compression		  // 01 06 00 03 00 00 00 01 00 02 00 00 262 PhotometricInterpretation		  // 01 11 00 04 00 00 00 0D 00 00 82 BA  273 StripOffsets		  // 01 12 00 03 00 00 00 01 00 01 00 00  274 Orientation		  // 01 15 00 03 00 00 00 01 00 04 00 00  277 SamplesPerPixel		  // 01 16 00 03 00 00 00 01 00 2D 00 00  278 RowsPerStrip		  // 01 17 00 04 00 00 00 0D 00 00 82 EE   279 StripByteCounts		  // 01 1A 00 05 00 00 00 01 00 00 83 22  282 XResolution ***		  // 01 1B 00 05 00 00 00 01 00 00 83 2A  283 YResolution ***		  // 01 1C 00 03 00 00 00 01 00 01 00 00  284 PlanarConfiguration		  // 01 28 00 03 00 00 00 01 00 02 00 00  296 Resolution Unit		  // 01 52 00 03 00 00 00 01 00 02 00 00  338 ExtraSamples = 2 = unassociated alpha		  // 01 53 00 03 00 00 00 04 00 00 83 32  339 Sampleformat ***		  // 00 00 00 00 		  // 00 08 00 08 00 08 00 08 // 82B2 258 BitsperSample		  // 00 00 00 08 00 00 08 1E 00 00 10 34 //2 BA  273 StripOffsets		  // 00 00 18 4A 00 00 20 60 00 00 28 76 00 00 30 8C 00 00 38 A2 00 00 40 B8 00 00 48 CE 00 00 6B 48 00 00 73 5E  00 00 7B 74 		  // 00 00 08 16 00 00 08 16 00 00 08 16 // 82EE StripByteCounts		  // 00 00 08 16 00 00 08 16 00 00 08 16 00 00 08 16 00 00 08 16 00 00 08 16 00 00 22 7A 00 00 08 16 00 00 08 16 00 00 06 78 		  // 48 00 00 00 01 00 00 00 // 8322 282 XResolution		  // 48 00 00 00 01 00 00 00 // 832A 283 YResolution		  // 00 01 00 01 00 01 00 01 // 339 Sampleformat *** 1 = unsigned integer 		  		  		  //10: Image File Directory IFD		  		  opos = 288		  spos = opos + 4*pict.height		  fpos = spos + 4*pict.height		  		  if compression = 32773 then		    pack = true		  else 		    pack = false		  end if		  		  		  pos = 10		  pos=writetag(b,pos,254,4,1,0) //NewSubFileType		  pos=writetag(b,pos,256,4,1,pict.width)  //ImageWidth 256  1		  pos=writetag(b,pos,257,4,1,pict.height) //ImageLength 257 2		  pos=writetag(b,pos,258,3,channels,256) //BitsperSample points to 256 //4 with alpha		  pos=writetag(b,pos,259,3,1,compression)		  pos=writetag(b,pos,262,3,1,2) //PhotometricInterpretation 2=RGB		  pos=writetag(b,pos,273,4,pict.height,opos) //StripOffsets 273 points to 512		  pos =writetag(b,pos,274,3,1,1) // Orientation		  pos=writetag(b,pos,277,3,1,channels)   // SamplesPerPixel  4 with alpha		  pos=writetag(b,pos,278,3,1,1) // RowsPerStrip 		  pos=writetag(b,pos,279,4,pict.height,spos)  //StripByteCounts 		  pos=writetag(b,pos,282,5,pict.height,264) //XResolution, 283 points to 512		  pos=writetag(b,pos,283,5,pict.height,272) //YResolution 284 points to 512		  pos=writetag(b,pos,284,3,1,1) //PlanarConfiguration 1 = top left		  pos=writetag(b,pos,296,3,1,2) //ResolutionUnit 2		  pos=writetag(b,pos,296,3,channels,280) //Sampleformat		  		  if noalpha then		  else		    pos=writetag(b,142,338,3,1,2) // ExtraSamples Tag 2= unrelated alpha		  end if		  		  counttags = (b.position-10)/12		  b.writelong 0             //end of IFD or between IFD		  b.position = 8		  b.writeshort counttags		  		  		  // tag 258 bitspersample		  b.position = 256		  b.writeshort 8		  b.writeshort 8		  b.writeshort 8		  if noalpha then		  else		    b.writeshort 8		  end if		  		  // tag 283 XResolution Rationale		  b.Position = 264		  b.writelong &h48000000		  b.writelong &h01000000		  		  // tag 284 YResolution Rationale		  b.Position = 272		  b.writelong &h48000000		  b.writelong &h01000000		  		  // tag 339 sample format		  b.position = 280		  b.writeshort 1		  b.writeshort 1		  b.writeshort 1		  if noalpha then		  else		    b.writeshort 1		  end if		  		  		  g = pict.rgbSurface		  if noalpha then		  else		    h = alpha.rgBSurface		  end if		  		  mem = newmemoryBlock(pict.width*channels)		  mem.littleEndian = false		  		  // write one black line which can be reused		  blackstripstart = fpos		  b.position = blackstripstart		  if pack then		    pbwriteblack(b,channels*pict.width)		  else		    for k = 0 to pict.width -1		      b.writelong 0		    next		  end if		  if b.position mod 2 = 1 then //even start		    b.writebyte 0		  end if		  fpos = b.position		  blackstriplength = b.position - blackstripstart		  		  for i = 0 to pict.height-1		    		    if userCancelled then		      b.close		      f.delete		      return		    end if		    		    if bounding and (i<top or i>bottom) and false then //removed blackstrip shortcut		      //writing strip offset		      b.position = opos		      b.writelong blackstripstart		      opos = b.position		      		      // writing strip length		      b.position = spos		      b.writelong blackstriplength		       spos = b.position		    else		      //writing strip offset		      b.position = opos		      b.writelong fpos 		      opos = b.position		      		      //writing image data		      oldfpos = fpos		      b.position = fpos		      		      memoffset = 0		      		      for k = 0 to pict.width-1		        if bounding and (k<left or k>right) then		          if defaultwhite then		            mem.byte(memoffset) = 255		            mem.byte(memoffset+1) = 255		            mem.byte(memoffset+2) = 255		            memoffset = memoffset + 3		            if not noalpha then		              mem.byte(memoffset) = 0		              memoffset = memoffset + 1		            end		          else		            if noalpha then		              mem.short(memoffset) =0		              memoffset = memoffset + 2		              mem.byte(memoffset) = 0		              memoffset = memoffset + 1		            else		              mem.long(memoffset) = 0		              memoffset = memoffset + 4		            end		          end		        else		          c = g.pixel(k,i)		          mem.colorValue(memoffset,24) = c		          memoffset = memoffset + 3		          if not noalpha then		            a = h.pixel(k,i)		            mem.byte(memoffset) = 255 - a.green		            memoffset = memoffset + 1		          end if		        end if		      next		      if pack then		        mem2 = mem.runLengthEncode		        mem2.littleEndian = false		        b.write mem2.stringValue(0,mem2.size)		      else		        b.write mem.stringValue(0,mem.size)		      end if		      		      if b.position mod 2 = 1 then //even start		        b.writebyte 0		      end if		      fpos = b.position		      		      // writing strip length		      b.position = spos		      b.writelong fpos-oldfpos 		      spos = b.position		    end if		    		    		  next		  		  b.close		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function writetag(b as binarystream, p as integer, tag as integer,type as integer,size as integer, value as integer) As integer		  b.position = p		  b.writeshort tag		  b.writeshort type		  b.writelong size		  if type = 3 and size = 1then		    writeushort b,value		    b.writeshort 0		  else		    b.writelong value		  end if		  return p+12		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub writeushort(b as binarystream, i as integer)		  b.writebyte (i mod 65536)\256		  b.writebyte i mod 256		End Sub	#tag EndMethod	#tag Property, Flags = &h0		bottom As integer	#tag EndProperty	#tag Property, Flags = &h0		compression As integer	#tag EndProperty	#tag Property, Flags = &h0		defaultwhite As boolean	#tag EndProperty	#tag Property, Flags = &h0		f As folderitem	#tag EndProperty	#tag Property, Flags = &h0		left As integer	#tag EndProperty	#tag Property, Flags = &h0		right As integer	#tag EndProperty	#tag Property, Flags = &h0		top As integer	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="bottom"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="compression"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="defaultwhite"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="right"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="integer"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass