#tag ClassProtected Class Subtitle	#tag Method, Flags = &h0		Function AlignString() As string		  select case halign		  case KHalignCenter, KHalignCenterLeft		    return "center"		  case kHalignLeft		    return "left"		  case kHalignRight		    return "right"		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function backup() As memoryblock		  dim out as memoryblock		  dim i as integer		  // version 1.1		  out = newmemoryblock(320)		  out.littleEndian = false		  for i = 0 to 319		    out.byte(i) = 0		  next		  out.short(0) = 320		  out.short(2) = 2		  out.pstring(16) = left(standard,32)		  out.pstring(64) = left(font,96)		  out.short(192) = size		  out.short(194) = leading		  out.short(196) = spacing		  out.byte(200) = booleantoint(bold)		  out.byte(201) = booleantoint(italic)		  out.byte(202) = booleantoint(underline)		  out.short(224) = ver.value		  out.short(226) = halign		  out.short(228) = valign		  out.short(230) = height		  out.short(232) = width		  out.short(234) = widthreal		  out.short(236) = antialiasing		  out.short(238) = left.value		  out.short(240) = right.value		  out.short(242) = wrapmethod		  out.byte(244) = booleantoint(interlaced)		  out.byte(256) = textc.red		  out.byte(257) = textc.green		  out.byte(258) = textc.blue		  out.byte(259) = 100*textalpha		  out.short(260) = textsoft		  out.byte(272) = borderc.red		  out.byte(273) = borderc.green		  out.byte(274) = borderc.blue		  out.byte(275) = 100*borderalpha		  out.short(276) = borderwidth		  out.short(278) = bordersoft		  out.byte(288) = rectc.red		  out.byte(289) = rectc.green		  out.byte(290) = rectc.blue		  out.byte(291) = 100*rectalpha		  out.short(292) = rectsoft		  out.byte(304) = shadowc.red		  out.byte(305) = shadowc.green		  out.byte(306) = shadowc.blue		  out.byte(307) = 100*shadowalpha		  out.short(308) = shadowx		  out.short(310) = shadowy		  out.short(312) = shadowsoft		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function BackupToDict() As dictionary		  dim dict as dictionary		  dict = new dictionary		  		  dict.value("font") = font		  dict.value("size") = size		  dict.value("spacing") = spacing		  dict.value("leading") = leading		  dict.value("bold") = bold		  dict.value("italic") = italic		  dict.value("underline") = underline		  		  dict.value("vertical") = ver.value		  dict.value("halin") = halign		  dict.value("valign") = valign		  		  dict.value("standard") = standard		  dict.value("height") = height		  dict.value("width") = width		  dict.value("widthreal") = widthreal		  dict.value("antialiasing") = antialiasing		  dict.value("left") = left.value		  dict.value("right") = right.value		  dict.value("wrapmethod") = wrapmethod		  dict.value("interlaced") = interlaced		  		  dict.value("textcolor") = textc		  dict.value("textalpha") = textalpha		  dict.value("textsoft") = textsoft		  		  dict.value("bordercolor") = borderc		  dict.value("borderalpha") = borderalpha		  dict.value("bordersoft") = bordersoft		  dict.value("borderwidth") = borderwidth		  		  dict.value("rectcolor") = rectc		  dict.value("rectalpha") = rectalpha		  dict.value("rectsoft") = rectsoft		  dict.value("rectform") = rectform		  		  dict.value("shadowcolor") = shadowc		  dict.value("shadowalpha") = shadowalpha		  dict.value("shadowsoft") = shadowsoft		  dict.value("shadowx") = shadowx		  dict.value("shadowy") = shadowy		  		  dict.value("framerate") = framerate		  		  return dict		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CalculateCharactersPerLine() As integer		  dim i,w,ten as integer		  dim p as picture		  dim g as graphics		  		  w = right.value -  left.value 		  		  p = newpicture(10,10,32)		  		  g = p.graphics		  g.useOldRenderer = true		  g.bold = bold		  g.italic = italic		  g.underline = underline		  g.textfont = font		  g.textsize = size		  		  ten = g.StringWidthWithSpace("nnnnnnnnnn",spacing,"nnnnnnnnnn")		  		  		  		  i = 10.0 * w / ten		  		  return i		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub clone(from as subtitle)		  		  antialiasing = from.antialiasing		  bold = from.bold		  borderalpha = from.borderalpha		  borderc = from.borderc		  bordersoft = from.bordersoft		  borderwidth = from.borderwidth		  bottom = from.bottom		  font = from.font		  framerate = from.framerate		  halign = from.halign		  height = from.height		  italic = from.italic		  leading = from.leading		  left.clone from.left		  rectalpha = from.rectalpha		  rectc = from.rectc		  rectform = from.rectform		  rectsoft = from.rectsoft		  right.clone from.right		  shadowalpha = from.shadowalpha		  shadowc = from.shadowc		  shadowsoft = from.shadowsoft		  shadowx = from.shadowx		  shadowy = from.shadowy		  size = from.size		  spacing = from.spacing		  standard = from.standard		  textalpha = from.textalpha		  textc = from.textc		  textsoft = from.textsoft		  top = from.top		  underline = from.underline		  valign = from.valign		  ver.clone from.ver		  wrapmethod = from.wrapmethod		  width = from.width		  widthreal = from.widthreal		  interlaced = from.interlaced		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function color2RGBString(c as color) As string		  return "("+str(c.red)+","+str(c.green)+","+str(c.blue)+") "		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  constructor("PAL")		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(st as string)		  dim i as integer		  left = new avxnumber		  right = new avxnumber		  ver = new avxnumber		  setstandard st		  		  font = "Geneva"		  		  size = 36		  bold = false		  italic = false		  underline = false		  textc = rgb(235,235,235)		  textalpha = 1		  borderc = rgb(16,16,16)		  borderalpha = 0.5		  borderwidth = 2		  bordersoft = 0		  shadowc = rgb(127,127,127)		  shadowalpha = 0.0		  shadowx = 2		  shadowy = 2		  ver.value= height*0.75		  left.value = width*0.1		  right.value = width*0.9		  halign = khalignCenter		  valign = khalignCenter		  wrapmethod = kwrapSmart		  shadowkind = 0		  wrappicture = newpicture(10,10,32)		  wrapgraphics = wrappicture.graphics		  leading = 0		  framerate = "25"		  		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CreateBorderPattern(tp as picture, w as integer) As picture		  dim p1,p2,p3, tp1 as picture		  dim i,j as integer		  dim invertmap(255) as integer		  		  // not used		  		  for i = 0 to 255		    invertmap(i) = 255-i		  next		  		  tp.transparent = 1		  p1 = newpicture(tp.width, tp.height,1)		  p1.graphics.useOldRenderer = true		  for i = - w to w 		    for j = -w to w		      if i*i + j*j <= w*w then		        p1.graphics.drawpictureHQ tp, i,j		      end		    next		  next		  		  p2 = newpicture(tp.width, tp.height, 32)		  p2.graphics.useOldRenderer = true		  p2.graphics.drawpictureHQ tp,0,0		  p2.rgBSurface.transform(invertmap)		  p3 = newpicture(tp.width, tp.height,1)		  p3.graphics.useOldRenderer = true		  p3.graphics.drawpictureHQ p2,0,0		  p3.transparent = 1		  p1.graphics.drawpictureHQ p3,0,0		  		  return p1		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function DVDinfo(key as string) As string		  dim s as string		  dim bgc, tc, o1c, o2c as integer		  dim bga, ta, o1a, o2a, v as double		  dim bgcc, tcc, o1cc, o2cc as color		  		  bgc = 15 // changed 1.7b17 0 is not possible in SST		  bga = 0		  bgcc = &cffffff		  tc = 3		  ta = textalpha * 15		  tcc = textc		  		  if borderalpha=0 and rectalpha=0 then		    // black = title		    // red = 66% of title		    // blue = 33% of title		    o1c = 3		    o1a = ta * 2 / 3		    o1c = tc		    o2c = 3		    o2a = ta / 3		    o2c = tc		    o1cc = tcc		    o2cc = tcc		  elseif rectalpha=0  then		    // black = title		    // red = 50% title and 50% border		    // blue = border		    o2c = 1		    o2a = borderalpha * 15		    o2cc = borderc		    o1c = 4		    o1a = (ta + o2a) / 2		    o1cc = rgb((tcc.red + o2cc.red)/2,(tcc.green + o2cc.green)/2,(tcc.blue + o2cc.blue)/2)		  elseif borderalpha=0  then		    // black = title		    // red = 50% title and 50% rect		    // blue = rect		    o2c = 2		    o2a = rectalpha * 15		    o2cc = rectc		    o1c = 5		    o1a = (ta + o2a) / 2		    o1cc = rgb((tcc.red + o2cc.red)/2,(tcc.green + o2cc.green)/2,(tcc.blue + o2cc.blue)/2)		  else		    // shadowalpha is ignored		    // black = title		    // red = border		    // blue = rect		    o1c = 1		    o1a = borderalpha * 15		    o1cc = borderc		    o2a = 2 		    o2a = rectalpha * 15		    o2cc = rectc		  end		  		  select case key		  case "TextColor"		    return str(tc)		  case "Outline1Color"		    return str(o1c)		  case "Outline2Color"		    return str(o2c)		  case "BackgroundColor"		    return str(bgc)		  case "TextContrast"		    return str(round(ta))		  case "Outline1Contrast"		    return str(round(o1a))		  case "Outline2Contrast"		    return str(round(o2a))		  case "BackgroundContrast"		    return str(bga)		  case "Comments"		    if borderalpha = 0 and rectalpha = 0 then		      s = "Palette " + str(tc) + " " + color2RGBString(tcc) 		    else		      s = "Palette " + str(tc) + " " + color2RGBString(tcc) + " " _		      + str(o1c) + " " + color2rGBString(o1cc) + " "  _		      + str(o2c) + " " + color2rGBString(o2cc)		    end		    return s 		  case "WhiteColor"		    return "(0,0,0)"		  case "BlackColor"		    return color2RGBString(tcc) 		  case "RedColor"		    return color2rGBString(o1cc)		  case "BlueColor"		    return color2rGBString(o2cc)		  case "WhiteMask"		    return "(255,255,255)"		  case "BlackMask"		    v = 255-ta*255/15		    return color2rGBString(rgb(v,v,v))		  case "RedMask"		    v = 255-o1a*255/15		    return color2rGBString(rgb(v,v,v))		  case "BlueMask"		    v = 255-o2a*255/15		    return color2rGBString(rgb(v,v,v))		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub EnlargeBlackRegions(p as picture, delta as integer)		  dim surf as rgbsurface		  dim map,weights as memoryblock		  dim i,j,k, pw,ph, blocksize, mapsize as integer		  dim test as boolean		  		  surf = p.rgbSurface		  pw = p.width		  ph=p.height		  		  blocksize = 2*delta+1		  mapsize = blocksize*blocksize		  		  weights = newmemoryBlock(mapsize)		  weights.littleEndian = false		  		  // init weight block 		  for i = 0 to blocksize-1		    for j = 0 to blocksize-1		      if (i-delta)*(i-delta) + (j-delta)*(j-delta) <= delta*delta then		        weights.byte(i*blocksize+j)=1		      else		        weights.byte(i*blocksize+j)=0		      end		    next		  next		  		  map = newmemoryBlock(mapsize)		  map.littleEndian = false		  		  for j = 0 to ph		    // read initial block, with one offset, because of inner loop		    for i = 1 to blocksize-1		      for k = 0 to blocksize -1		        if i+delta<0 or i+delta>pw-1 then		          map.byte(i*blocksize+k) = 0		        elseif j-delta+k < 0 or j-delta+k>ph-1 then		          map.byte(i*blocksize+k) = 0		        else		          map.byte(i*blocksize+k) = surf.pixel(i+delta,j-delta+k).green		        end		      next		    next		    		    for i = 0 to pw		      // offset blocks 		      for k = 0 to blocksize*(blocksize-1)		        map.byte(k) = map.byte(k+blocksize)		      next		      // read new blocks 		      for k = 0 to blocksize-1		        if i+delta>pw-1 then		          map.byte(blocksize*(blocksize-1)+k) = 0		        elseif j-delta+k < 0 or j-delta+k>ph-1 then		          map.byte(blocksize*(blocksize-1)+k) = 0		        else		          map.byte(blocksize*(blocksize-1)+k) = surf.pixel(i+delta,j-delta+k).green		        end		      next		      // look for black pixels in neighbourhood		      test = false		      for k = 0 to mapsize-1		        test = test or map.byte(k)=0 and weights.byte(k)=1		        if test then		          exit		        end		      next		      if test then 		        surf.pixel(i,j)=rgb(0,0,0)		      end		    next		  next		  		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function FCPanamorphic() As boolean		  select case standard		  case "PAL 16:9", "NTSC 16:9", "NTSC 16:9 DV"		    return true		  else		    return false		  end select 		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function FCPpixelaspectratio() As string		  'pixelaspectratio 		  'Description A string specifying the pixel aspect ratio. 		  'Parent samplecharacteristics 		  'Notes Valid entries are NTSC-601, PAL-601, square, DVCPROHD-720P or HD-(960x720), 		  'DVCPROHD-1080i60 or HD-(1280x1080), DVCPROHD-1080i50 or HD-(1440x1080). 		  		  		  		  select case standard		  case "PAL", "PAL 16:9", "PAL DVD"		    return "PAL-CCIR-601"		  case "NTSC", "NTSC 16:9", "NTSC DV", "NTSC 16:9 DV", "NTSC DVD"		    return "NTSC-CCIR-601"		  case "HDV 1080i"		    return "HD-(1440x1080)"		  else		    return "square"		  end select 		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetTimeCode() As Timecode		  select case framerate		  case "23.98"		    return new timecode(24,24000/1001.0,false)		  case "24"		    return new timecode(24,24,false)		  case "25"		    return new timecode(25,25,false)		  case "29.97 DF"		    return new timecode(30,30000/1001.0,true)		  case "29.97 NDF"		    return new timecode(30,30000/1001.0,false)		  case "30"		    return new timecode(30,30,false)		  case "50"		    return new timecode(50,50,false)		  case "59.94"		    return new timecode(60,60000/1001,true)		  else		    return new timecode		  end		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub GetTopBottom(f as string, sz as integer, byref tp as integer, byref bt as integer)		  dim p as picture		  dim surf as rgbsurface		  dim x,y, t, w, b ,result as integer		  w = 2*sz		  p = new picture(w, w, 32)		  p.graphics.textfont = f		  p.graphics.textsize = sz		  p.graphics.drawstring "Tg",0,sz		  		  surf =p.rgBSurface		  		  t = -1		  b= -1		  w = w-1		  for y = 0 to w		    for x = 0 to w		      if surf.pixel(x,y) <> &cffffff then		        t  = y		        exit		      end		    next		    if t>=0 then exit		  next		  		  tp = t - 0.14 * sz		  		  for y = w  downTo 0		    for x = 0 to w		      if surf.pixel(x,y) <> &cffffff then		        b  = y		        exit		      end		    next		    if b>=0 then exit		  next		  		  bt = b + 0.07 * sz		  		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetTsize(f as string, sz as integer) As integer		  dim p as picture		  dim surf as rgbsurface		  dim x,y, t, w, b ,result as integer		  w = 2*sz		  p = new picture(w, w, 32)		  p.graphics.textfont = f		  p.graphics.textsize = sz		  p.graphics.drawstring "Tg",0,sz		  		  surf =p.rgBSurface		  		  t = -1		  b= -1		  w = w-1		  for y = 0 to w		    for x = 0 to w		      if surf.pixel(x,y) <> &cffffff then		        t  = y		        exit		      end		    next		    if t>=0 then exit		  next		  		  for y = w  downTo 0		    for x = 0 to w		      if surf.pixel(x,y) <> &cffffff then		        b  = y		        exit		      end		    next		    if b>=0 then exit		  next		  		  '0		  't		  'sz		  'b		  '0		  		  result = (b-sz) + t		  return result		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function reducebits(p as picture, w as integer, h as integer) As picture		  dim p1,p2 as picture		  dim black1, black2, black3 as integer		  dim i,j,map(255),x,y as integer		  dim c as color		  dim surf,surfsource as rgbsurface		  dim pixelsum as integer		  dim xscale, yscale as double		  		  p1 = newpicture(w,h,32)		  p1.graphics.useOldRenderer = true		  p1.graphics.drawpicture p,0,0,p1.width,p1.height,0,0,p.width,p.height		  		  xscale= p.width/p1.width		  yscale = p.height/p1.height		  		  'soften p1,1,1		  		  'for i = &h00 to &h7f		  'map(i) = 0		  'next		  'for i = &h80 to &hff		  'map(i) = 255		  'next		  'p1.rgbSurface.transform map,map,map		  surfsource = p.rgbSurface		  surf = p1.rgBSurface		  for x = 0 to w-1		    for y = 0 to h-1		      c = surfsource.pixel(x*xscale,y*yscale)		      pixelsum = c.green + c.blue + c.red		      if pixelsum > 588 then		        surf.Pixel(x,y) = &cffffff		      elseif pixelsum < 192 then		        surf.Pixel(x,y) = &c000000		      else		        for i = -1 to 1		          for j = -1 to 1		            c = surfsource.Pixel((x+i)*xscale,(y+j)*yscale)		            pixelsum = pixelsum + c.green + c.blue + c.red		          next		        next		        if pixelsum > 3839 then   // 128*10*3-1		          surf.Pixel(x,y) = &cffffff		        else		          surf.Pixel(x,y) = &c000000		        end		      end		    next		  next		  		  // reduce single pixels		  'surf = p1.rgBSurface		  'for y = 0 to h-1		  'black1 = -1		  'black2 = -1		  'black3 = -1		  'for x = 0 to w-1		  'c = surf.pixel(x,y)		  'if c = &c000000 then 		  'black3 = 1		  'if black2 = 0 and black1 = 1 then		  'surf.pixel(x-1,y) = &c000000		  'end		  'else		  'black3 = 0		  'if black2 = 1 and black1 = 0 then		  'surf.pixel(x-1,y) = &cffffff		  'end		  'end		  'black2 = black3		  'black1 = black2		  'next		  'next		  		  		  		  return p1		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub render(st as string,frame as picture, alpha as picture,receiver as eventreceiver)		  dim g,ga,ba,tp, bp as graphics		  dim xlayout, xlayout2, ylayout, x, y, xl , theight, tasc, tsize as integer		  dim talpha, salpha, ralpha as integer		  dim s,sa as rgbsurface		  dim sw1,sw2, sw as integer		  dim antix as double		  dim boxleft, boxright,boxtop,boxbottom, voffset, boxwidth, boxheight  as integer		  dim framewidth, frameheight, bigwidth, bigheight, bandheight as integer		  dim pixelalpha, pixelred, pixelgreen, pixelblue, altpixelalpha, altpixelred, altpixelgreen, altpixelblue as double		  dim newpixelalpha, newpixelred, newpixelgreen, newpixelblue as double		  dim pixelcolor, altpixelcolor as color		  dim i,j as integer		  dim inn,in2,encodingstring as string		  dim rad as integer		  dim balpha as double		  dim textpattern, textpattern1,borderpattern, boxpicture,boxpicture2,noanti, tpdvd as picture		  dim textpattern0, textpatternstamp as picture		  dim hoffset as integer		  dim textenc as textencoding		  dim startx,starty,endx,endy as integer		  dim dvdp as picture		  dim fx, fy as double		  dim recttop,rectbottom as integer		  		  if not app.qtok then return		  		  app.consolelog "subtitle:render " + left(st,16)		  		  inn = nthfield(st,endofline,1)		  in2 = nthfield(st,endofline,2)		  if in2<>"" then 		    encodingstring = inn+in2 // encodingstring //1.7.7 was empty 		  else		    encodingstring = inn  // empty string is US_ASCII!		  end		  		  		  framewidth = frame.width		  frameheight = frame.height		  antix = antialiasing*widthreal/width		  		  talpha = 255*(1-textalpha)		  salpha = 255*(1-shadowalpha)		  balpha = 255*(1-borderalpha)		  		  g = frame.graphics		  g.useOldRenderer = true		  g.forecolor = rgb(0,0,0)		  g.fillrect 0,0,framewidth,frameheight		  		  ga = alpha.graphics		  ga.useOldRenderer = true		  ga.clearrect 0,0,framewidth,frameheight		  		  select case valign		  case kvaligntop		    ylayout = ver.value + size		  case kvaligncenter		    if in2 = "" then		      ylayout =  ver.value + (size+leading) / 2		    else		      ylayout = ver.value		    end if		  case kvalignbottom		    if in2 = "" then		      ylayout =ver.value		    else		      ylayout =ver.value-(size+leading)		    end if		  end select 		  		  hoffset = size*widthreal/width + abs(shadowx)+borderwidth+textsoft+bordersoft+rectsoft+shadowsoft		  voffset = abs(shadowy)+borderwidth+textsoft+bordersoft+rectsoft+shadowsoft		  		  //test for stringwidth		  textpattern = newpicture(10,10,32)		  tp = textpattern.graphics		  tp.useOldRenderer = true		  tp.bold = bold		  tp.italic = italic		  tp.underline = underline		  tp.textfont = font		  tp.textsize = antialiasing*size		  sw1 = tp.stringWidthwithspace(inn, antix*spacing,encodingstring) '+ len(inn)* antix*spacing		  sw2 = tp.stringWidthwithspace(in2, antix*spacing,encodingstring) '+ len(in2)* antix*spacing		  textpattern = nil		  		  		  select case halign		  case 0 // left 		    xlayout =left.value		    xlayout2 = left.value		  case 1 // center		    xlayout = left.value/2+right.value/2 -sw1/antix/2		    xlayout2 =  left.value/2+right.value/2 -sw2/antix/2		  case 2 // right		    xlayout = right.value-sw1/antix		    xlayout2 = right.value-sw2/antix		  case 3 // center left		    xlayout = left.value/2+right.value/2 -max(sw1,sw2)/antix/2		    xlayout2 =  xlayout		  end select 		  		  boxleft = min(xlayout,xlayout2)-hoffset		  boxright = max(xlayout+sw1/antix,xlayout2+sw2/antix)+hoffset		  boxtop = ylayout -1.3*size- voffset		  boxbottom =  min(ylayout +1.5*size + voffset,height-2)		  		  if rectform = 3 or rectform = 4 then  //fixed		    boxleft = left.value		    boxright = right.value		  end		  		  		  		  		  boxwidth = boxright-boxleft		  boxheight = boxbottom-boxtop		  		  		  		  top = boxtop		  bottom = boxbottom		  		  textpattern1 = newpicture(boxwidth*antix,boxheight*antialiasing,32)  // must be 32 because of textencoding		  //1 bit is not unicode save!!		  		  		  boxpicture = newpicture(boxwidth,boxheight,32)		  boxpicture2 = newpicture(boxwidth,boxheight,32)		  		  if textpattern1=nil or boxpicture = nil or boxpicture2 = nil then		    msgbox "Error Render. Give more memory"		    return		  end		  boxpicture.graphics.useoldRenderer = true		  boxpicture.mask.graphics.useOldRenderer = true		  boxpicture2.graphics.useOldRenderer = true		  boxpicture2.mask.graphics.useOldRenderer = true		  		  textpattern1.graphics.useOldRenderer = true		  tp=textpattern1.graphics		  tp.useOldRenderer = true		  tp.clearrect 0,0,boxwidth,boxheight		  tp.bold = bold		  tp.italic = italic		  tp.underline = underline		  tp.textfont = font		  tp.textsize = antialiasing*size 		  tp.penheight = antialiasing*size/12		  tp.forecolor = rgb(0,0,0)		  		  tp.drawstringWithSpace inn, antix*(xlayout-boxleft),antialiasing* (size + voffset ), antix*spacing, encodingstring		  		  tp.drawstringWithSpace in2, antix*(xlayout2-boxleft),antialiasing* (2*size + leading + voffset ), antix*spacing, encodingstring		  		  textpattern = newpicture(textpattern1.width,textpattern1.height,32)		  textpattern.graphics.useOldRenderer = true		  textpattern.graphics.drawpicture textpattern1,0,0		  		  		  if dvdtext then		    textpattern = reducebits(textpattern,boxwidth,boxheight)		  end		  		  		  		  		  app.consolelog "subtitle:render:textpattern end"		  receiver.doevents		  		  		  		  		  		  app.consolelog "subtitle:render:borderpattern end"		  receiver.doevents		  		  // drawing rect		  if rectalpha>0 then		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    for rad = rectsoft downto -rectsoft		      if rectsoft > 0 then		        ralpha = 255*(1-rectalpha*(rectsoft-rad)/2/rectsoft)		      else		        ralpha = 255*(1-rectalpha)		      end		      boxpicture2.mask.graphics.forecolor = rgb(ralpha,ralpha,ralpha)		      boxpicture2.mask.graphics.textfont = font		      boxpicture2.mask.graphics.textsize = size		      theight = boxpicture2.mask.graphics.textheight		      tasc = boxpicture2.mask.graphics.textascent		      tsize = 5 * (boxpicture2.mask.graphics.textsize - tasc)		      tsize = (tsize + 2 * (theight - tsize) )/2		      tsize = gettsize(font,size)		      gettopBottom(font,size,recttop,rectbottom)		      select case rectform		      case 4		        boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height+2*(rad-rectsoft)		      case 3		        if sw2>0 or true then		          boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height+2*(rad-rectsoft)		        else		          boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height/2+2*(rad-rectsoft)		        end		      case 1		        sw = max(sw1, sw2)		        xl = min(xlayout, xlayout2)		        if sw2 = 0 then		          boxpicture2.mask.graphics.fillrect xlayout-boxleft-0.15*size-rad,voffset+recttop-rad,sw/antix+0.3*size+2*rad,rectbottom-recttop+ 2*rad		        else		          boxpicture2.mask.graphics.fillrect xl-boxleft-0.15*size-rad,voffset+recttop-rad,sw/antix+0.3*size+2*rad,size+leading + rectbottom-recttop+2*rad		        end		      case 2		        if sw1 > 0 then		          boxpicture2.mask.graphics.fillrect xlayout-boxleft-0.15*size-rad,voffset+recttop-rad,sw1/antix+0.3*size+2*rad, rectbottom-recttop+2*rad		        end		        if sw2 > 0 then		          boxpicture2.mask.graphics.fillrect xlayout2-boxleft-0.15*size-rad,voffset+size+leading+recttop-rad,sw2/antix+0.3*size+2*rad,rectbottom-recttop+2*rad		        end		      end		    next		    		    boxpicture2.graphics.forecolor = rectc		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    g.drawpictureHQ boxpicture2,boxleft,boxtop		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft,boxtop		    		    boxpicture2.graphics.clearrect 0,0,boxwidth,boxheight  // test		    boxpicture2.mask.graphics.forecolor = rgb(0,0,0)		    boxpicture2.mask.graphics.fillrect 0,0,boxwidth,boxheight		  end		  		  app.consolelog "subtitle:render:rect end"		  receiver.doevents		  		  // drawing shadow		  		  if shadowalpha >0 then		    boxpicture2.graphics.drawpictureHQ textpattern,0,0,boxwidth,boxheight,0,0,textpattern.width,textpattern.height		    // fixed x3		    if shadowsoft > 0 then		      soften boxpicture2,shadowsoft*width/widthreal,shadowsoft		    end		    boxpicture.mask.graphics.drawpictureHQ boxpicture2,0,0		    		    boxpicture.graphics.forecolor = rgb(salpha,salpha,salpha)		    boxpicture.graphics.fillrect 0,0,boxwidth,boxheight		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    boxpicture2.mask.graphics.drawpictureHQ boxpicture,0,0		    		    boxpicture2.graphics.forecolor = shadowc		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    g.drawpictureHQ boxpicture2,boxleft+shadowx,boxtop+shadowy		    		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft+shadowx,boxtop+shadowy		    		    boxpicture2.mask.graphics.forecolor = rgb(0,0,0)		    boxpicture2.mask.graphics.fillrect 0,0,boxwidth,boxheight		  end		  		  app.consolelog "subtitle:render:shadow end"		  receiver.doevents		  		  // drawing border 		  		  if borderalpha > 0  and borderwidth > 0 then		    		    borderpattern = newpicture(boxwidth,boxheight,32)		    borderpattern.graphics.useOldRenderer = true		    textpatternstamp = newpicture(boxwidth,boxheight,32)		    textpatternstamp.graphics.useOldRenderer = true		    		    textpatternstamp.mask.graphics.drawpictureHQ textpattern,0,0,textpatternstamp.width,textpatternstamp.height,0,0,textpattern.width,textpattern.height		    textpatternstamp.graphics.foreColor = &c000000		    textpatternstamp.graphics.fillrect 0,0, textpattern.width,textpattern.height		    if dvdborder then		      textpatternstamp.mask.graphics.drawpicture reducebits(textpatternstamp.mask,boxwidth,boxheight),0,0		      fx = 0.7 '* width/widthreal		      fy = 0.7		    else		      fx = 0.5 * width/widthreal		      fy = 0.5		    end		    		    		    bp=borderpattern.graphics // carbon test		    bp.useOldRenderer = true		    		    for i = -borderwidth to borderwidth		      for j = -borderwidth to borderwidth		        if i*i + j*j <= borderwidth*borderwidth then		          bp.drawpictureHQ textpatternstamp,i*fx,j*fy  // 1.6 b2 finer border		        end		      next		    next		    		    textpatternstamp.graphics.foreColor = &cffffff		    textpatternstamp.graphics.fillrect 0,0, textpattern.width,textpattern.height		    		    // must be more complicated.when equal, just do not draw and do not draw later.		    if not dvdborder and (textalpha = 0.0 or textalpha< borderalpha) then		      bp.drawpictureHQ textpatternstamp,0,0		    end		    		    boxpicture2.graphics.drawpictureHQ borderpattern,0,0,boxwidth,boxheight,0,0,borderpattern.width,borderpattern.height		    if bordersoft > 0 then		      soften boxpicture2,bordersoft*width/widthreal,bordersoft		    end		    boxpicture.mask.graphics.drawpictureHQ boxpicture2,0,0		    		    boxpicture.graphics.forecolor = rgb(balpha,balpha,balpha)		    boxpicture.graphics.fillrect 0,0,boxwidth,boxheight		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    boxpicture2.mask.graphics.drawpictureHQ boxpicture,0,0		    		    boxpicture2.graphics.forecolor = borderc		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    g.drawpictureHQ boxpicture2,boxleft,boxtop		    		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft,boxtop		    		    boxpicture2.mask.graphics.forecolor = rgb(0,0,0)		    boxpicture2.mask.graphics.fillrect 0,0,boxwidth,boxheight		  end		  		  app.consolelog "subtitle:render:border end"		  receiver.doevents		  		  		  // drawing title 		  		  		  if textalpha > 0 then		    		    textpattern.transparent = 0		    boxpicture2.graphics.drawpictureHQ textpattern,0,0,boxwidth,boxheight,0,0,textpattern.width,textpattern.height		    if textsoft > 0 then		      soften boxpicture2,textsoft*width/widthreal,textsoft		    end		    boxpicture.mask.graphics.drawpictureHQ boxpicture2,0,0		    		    boxpicture.graphics.forecolor = rgb(talpha,talpha,talpha)		    boxpicture.graphics.fillrect 0,0,boxwidth,boxheight		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    boxpicture2.mask.graphics.drawpictureHQ boxpicture,0,0		    		    boxpicture2.graphics.forecolor = textc		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    g.drawpictureHQ boxpicture2,boxleft,boxtop		    		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft,boxtop		  end		  		  		  app.consolelog "subtitle:render:text end"		  		  		  'if prog <> nil then prog.value = 50		  receiver.doevents		  		  		  s = frame.rgbsurface		  sa = alpha.rgbsurface		  		  		  // loop pixels		  		  // limit box to actual dimensions		  boxleft = min(frame.width-1,max(0,boxleft))		  boxright = min(frame.width-1,max(0,boxright))		  boxtop = min(frame.height-1,max(0,boxtop))		  boxbottom = min(frame.height-1,max(0,boxbottom))		  		  for x = boxleft to boxright		    altpixelalpha = sa.pixel(x,boxtop).green		    altpixelcolor = s.pixel(x,boxtop)		    altpixelred = altpixelcolor.red		    altpixelgreen = altpixelcolor.green		    altpixelblue =  altpixelcolor.blue		    		    		    for y = boxtop to boxbottom		      		      //demultiply and deflicker		      		      newpixelalpha = sa.pixel(x,y+1).green		      		      if interlaced then		        pixelalpha = (altpixelalpha + newpixelalpha)/2		        if pixelalpha <> altpixelalpha then		          sa.pixel(x,y)= rgb(pixelalpha,pixelalpha,pixelalpha)		        end		      else		        pixelalpha = altpixelalpha		      end		      		      pixelcolor = s.pixel(x,y+1)		      		      newpixelred = pixelcolor.red		      newpixelgreen = pixelcolor.green		      newpixelblue = pixelcolor.blue		      		      if pixelalpha < 255 then		        if interlaced then		          pixelred = (altpixelred+newpixelred)/2		          pixelgreen = (altpixelgreen+newpixelgreen)/2		          pixelblue = (altpixelblue + newpixelblue)/2		        else		          pixelred = altpixelred		          pixelgreen = altpixelgreen		          pixelblue = altpixelblue		        end		        		        'if not dvdborder then		        pixelred = pixelred*255/(255-pixelalpha)		        pixelgreen = pixelgreen*255/(255-pixelalpha)		        pixelblue = pixelblue*255/(255-pixelalpha)		        'end		        		        		        		        s.pixel(x,y) = rgb(pixelred,pixelgreen,pixelblue)		      end		      		      altpixelalpha = newpixelalpha		      altpixelred = newpixelred		      altpixelgreen = newpixelgreen		      altpixelblue = newpixelblue		      		    next		    // end column		    		    		    		    if userCancelled then		      return		    end		    		    		  next		  		  app.consolelog "subtitle:render:demultiply end"		  receiver.doevents		  		  		  receiver.doevents		  		  app.consolelog "subtitle:render end" 		  		exception err as nilObjectException		  msgBox "Error Subtitle:Render Nil Object Exception"		  		  error = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RenderDVD(st as string,frame as picture, alpha as picture,prog as eventreceiver)		  // define antialiasing depending on the colors		  dim p as picture		  dim i as integer		  dim rmap(255), gmap(255), bmap(255) as integer		  dim limit1, limit2, limit3,x,y,w,h as integer		  dim surf as rgbsurface		  dim gray as picture		  dim m as picture		  dim vtext,vborder,vrect as integer		  dim c as color		  		  if not app.qtok then return		  		  		  frame.graphics.useOldRenderer = true		  		  p = newpicture(frame.width,frame.height,32)		  p.graphics.useOldRenderer = true		  		  bordersoft  = 0		  rectsoft = 0		  		  textc = &cffffff		  textalpha = 1.0		  shadowalpha = 0.0 // shadowalpha is ignored		  		  select case standard		  case "PAL DVD", "NTSC DVD"		    if textsoft=0 then		      antialiasing = 1		    else		      antialiasing = 4		    end		  else		    		    antialiasing = 4		    		  end		  interlaced = false		  		  		  		  if borderalpha=0 and  rectalpha=0 then		    		    		    if textsoft > 0 then		      // black = title		      // red = 66% of title		      // blue = 33% of title		      limit1 = 255 * 0.25		      limit2 = 255 * 0.5		      limit3= 255 * 0.75		      textsoft  = 0		      dvdtext = false		      render st, frame, alpha, prog		      		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          vtext = surf.pixel(x,y).green		          if vtext<limit1 then		            surf.pixel(x,y) = &cffffff		          elseif vtext<limit2 then		            surf.pixel(x,y) = &c0000ff		          elseif vtext<limit3 then		            surf.pixel(x,y) = &cff0000		          else		            surf.pixel(x,y) = &c000000		          end		        next		      next		      		    else		      // black = title		      limit1 = 255 *0.5		      limit2 = limit1		      limit3 = limit1		      textsoft  = 0		      dvdtext = true		      render st, frame, alpha, prog		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          vtext = surf.pixel(x,y).green		          if vtext<limit1 then		            surf.pixel(x,y) = &cffffff		          else		            surf.pixel(x,y) = &c000000		          end		        next		      next		      		      		    end		    		  elseif borderalpha=0  then		    		    if textsoft>0 then		      // black = title		      // red = 50% title and 50% rect		      // blue = rect		      'rectc = &c808080		      textc = &c00ffff		      rectc = &c0000ff		      rectalpha = 1.0		      limit1 = &h80 * 0.5		      limit2 = &h80 + (&hff-&h80)*0.33		      limit3 = &h80 + (&hff-&h80)*0.66		      textsoft = 0		      dvdtext = false		      render st, frame, alpha, prog		      		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          c = surf.pixel(x,y)		          vtext = c.green		          vrect = c.blue		          if vtext>16 then		            if vtext>100 then		              surf.pixel(x,y) = &c000000		            else		              surf.pixel(x,y) = &cff0000		            end		          elseif vrect>16 then		            surf.pixel(x,y) = &c0000ff		          else		            surf.pixel(x,y) = &cffffff		          end		        next		      next		      		      		    else		      // black = title		      // blue = rect		      textc = &c00ffff		      rectc = &c0000ff		      rectalpha = 1.0		      limit1 = &h80 * 0.5		      limit2 = &h80 + (&hff-&h40)*0.5 		      limit3 = limit2		      textsoft = 0		      dvdtext = true		      render st, frame, alpha, prog		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          c = surf.pixel(x,y)		          vtext = c.green		          vrect = c.blue		          if vtext>16 then		            surf.pixel(x,y) = &c000000		          elseif vrect>16 then		            surf.pixel(x,y) = &c0000ff		          else		            surf.pixel(x,y) = &cffffff		          end		        next		      next		    end		    		  elseif rectalpha = 0 then		    		    if textsoft > 0 then		      // black = title		      // red = 50% title and 50% border		      // blue = border		      borderc = &cff0000		      textc = &cffff00		      borderalpha = 1.0		      limit1 = &h80 * 0.5		      limit2 = &h80 + (&hff-&h80)*0.33		      limit3 = &h80 + (&hff-&h80)*0.66		      textsoft = 0		      dvdtext = false		      dvdborder = true		      render st, frame, alpha, prog		      		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          c = surf.pixel(x,y)		          vtext = c.green		          vborder = c.red		          		          if vtext>128 then		            surf.pixel(x,y) = &c000000		          elseif vtext>16 then		            surf.pixel(x,y) = &cff0000		          elseif vborder > 16 then		            surf.pixel(x,y) = &c0000ff		          else		            surf.pixel(x,y) = &cffffff		          end		        next		      next		      		      		      		    else		      // black = title		      // blue = border		      borderc = &cff0000		      textc = &cffff00		      borderalpha = 1.0		      limit1 = &h80 * 0.5		      limit2 = &h80 + (&hff-&h80)*0.5		      limit3 = limit2		      textsoft = 0		      dvdtext = true		      dvdborder = true		      render st, frame, alpha, prog		      		      		      		      		      		      surf = frame.rgbSurface		      w = width -1		      h = height -1		      for y = 0 to h		        for x = 0 to w		          c = surf.pixel(x,y)		          vtext = c.green		          vborder = c.red		          if vtext>100 then		            surf.pixel(x,y) = &c000000		          elseif vborder>16 then		            surf.pixel(x,y) = &c0000ff		          else		            surf.pixel(x,y) = &cffffff		          end		        next		      next		    end		    		  else		    // black = title		    // red = border		    // blue = rect		    		    borderc = &cAAAAAA		    borderalpha = 1.0		    rectc = &c555555		    rectalpha = 1.0		    		    borderc = &cff00ff		    rectc = &c0000ff		    textc = &cffffff		    		    limit1 = &h55 * 0.5		    limit2 = &h55 + (&hAA-&h55)*0.5		    limit3 = &hAA + (&hFF-&hAA)*0.5		    		    textsoft = 0		    dvdtext = true		    dvdborder = true		    render st, frame, alpha, prog		    		    		    surf = frame.rgbSurface		    w = width -1		    h = height -1		    for y = 0 to h		      for x = 0 to w		        c = surf.pixel(x,y)		        vtext = c.green		        vrect = c.blue		        vborder = c.red		        if vtext>16 then		          surf.pixel(x,y) = &c000000		        elseif vborder>16 then		          surf.pixel(x,y) = &cff0000		        elseif vrect>16 then		          surf.pixel(x,y) = &c0000ff		        else		          surf.pixel(x,y) = &cffffff		        end		      next		    next		  end		  		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub renderDVDpreview(st as string,frame as picture, alpha as picture,dvdframe as picture, prog as eventreceiver)		  dim bgc,tc,o1c,o2c as color		  dim bgm, tm, o1m, o2m as color		  dim surf, surfa as rgbsurface		  dim x, y, w, h as integer		  		  // ask before render, after values are not valid any more		  bgc = string2RGBcolor(dvdinfo("WhiteColor"))		  tc = string2RGBColor(dvdinfo("BlackColor"))		  o1c = string2RGBColor(dvdinfo("RedColor"))		  o2c = string2RGBColor(dvdinfo("BlueColor"))		  		  bgm = string2RGBcolor(dvdinfo("WhiteMask"))		  tm = string2RGBColor(dvdinfo("BlackMask"))		  o1m = string2RGBColor(dvdinfo("RedMask"))		  o2m = string2RGBColor(dvdinfo("BlueMask"))		  		  renderDVD st, frame, alpha, prog		  		  dvdframe.graphics.drawpicture frame,0,0		  		  		  surf = frame.rGBSurface		  surfa = alpha.rgbSurface		  		  w = width -1		  h = height -1		  for y = 0 to h		    for x = 0 to w		      select case surf.pixel(x,y)		      case &cffffff		        surf.pixel(x,y) = bgc		        surfa.pixel(x,y) = bgm		      case &c000000		        surf.pixel(x,y) = tc		        surfa.pixel(x,y) = tm		      case &cff0000		        surf.pixel(x,y) = o1c		        surfa.pixel(x,y) = o1m		      case &c0000ff		        surf.pixel(x,y) = o2c		        surfa.pixel(x,y) = o2m		      end		    next		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RenderFast(st as string,frame as picture, alpha as picture)		  dim g,ga,ba,tp, bp as graphics		  dim xlayout, xlayout2, ylayout, x, y, xl , theight, tasc, tsize as integer		  dim talpha, salpha, ralpha as integer		  dim s,sa as rgbsurface		  dim sw1,sw2, sw as integer		  dim antix as double		  dim boxleft, boxright,boxtop,boxbottom, voffset, boxwidth, boxheight  as integer		  dim framewidth, frameheight, bigwidth, bigheight, bandheight as integer		  dim pixelalpha, pixelred, pixelgreen, pixelblue, altpixelalpha, altpixelred, altpixelgreen, altpixelblue as double		  dim newpixelalpha, newpixelred, newpixelgreen, newpixelblue as double		  dim pixelcolor, altpixelcolor as color		  dim i,j as integer		  dim inn,in2,encodingstring as string		  dim rad as integer		  dim balpha as double		  dim textpattern, borderpattern, boxpicture,boxpicture2,noanti as picture		  dim textpattern0, textpatternstamp as picture		  dim hoffset as integer		  dim textenc as textencoding		  dim startx,starty,endx,endy as integer		  dim dvdp as picture		  dim fx, fy as double		  		  		  		  		  if not app.qtok then return		  		  app.consolelog "subtitle:renderfast " + left(st,16)		  		  // change makes only RTrim now 26.2.3		  		  inn = Rtrim(nthfield(st,endofline,1))		  in2 = Rtrim(nthfield(st,endofline,2))		  		  if in2<>"" then 		    encodingstring = encodingstring		  else		    encodingstring = inn  // empty string is US_ASCII!		  end		  		  		  'textenc = getfontTextEncoding(me.font)		  'inn = inn.convertEncoding(textenc)		  'in2 = in2.convertEncoding(textenc)		  		  framewidth = frame.width		  frameheight = frame.height		  antix = antialiasing*widthreal/width 		  		  talpha = 255*(1-textalpha)		  salpha = 255*(1-shadowalpha)		  balpha = 255*(1-borderalpha)		  		  g = frame.graphics		  g.useOldRenderer = true		  g.forecolor = rgb(0,0,0)		  g.fillrect 0,0,framewidth,frameheight		  		  ga = alpha.graphics		  ga.useOldRenderer = true		  ga.clearrect 0,0,framewidth,frameheight		  		  select case valign		  case 0 // top		    ylayout = ver.value + size		  case 1 //center		    if in2 = "" then		      ylayout =  ver.value + (size+leading) / 2		    else		      ylayout = ver.value		    end if		  case 2 // bottom		    if in2 = "" then		      ylayout =ver.value		    else		      ylayout =ver.value-(size+leading)		    end if		  end select 		  		  hoffset = size*widthreal/width + abs(shadowx)+borderwidth+textsoft+bordersoft+rectsoft+shadowsoft		  voffset = abs(shadowy)+borderwidth+textsoft+bordersoft+rectsoft+shadowsoft		  		  //test for stringwidth		  textpattern = newpicture(10,10,32)		  tp = textpattern.graphics		  tp.useOldRenderer = true		  tp.bold = bold		  tp.italic = italic		  tp.underline = underline		  tp.textfont = font		  tp.textsize = antialiasing*size 		  sw1 = tp.stringWidthwithspace(inn, antix*spacing,encodingstring) '+ len(inn)* antix*spacing		  sw2 = tp.stringWidthwithspace(in2, antix*spacing,encodingstring) '+ len(in2)* antix*spacing		  textpattern = nil		  		  		  select case halign		  case 0 // left 		    xlayout =left.value		    xlayout2 = left.value		  case 1 // center		    xlayout = left.value/2+right.value/2 -sw1/antix/2		    xlayout2 =  left.value/2+right.value/2 -sw2/antix/2		  case 2 // right		    xlayout = right.value-sw1/antix		    xlayout2 = right.value-sw2/antix		  end select 		  		  boxleft = min(xlayout,xlayout2)-hoffset		  boxright = max(xlayout+sw1/antix,xlayout2+sw2/antix)+hoffset		  boxtop = ylayout -1.3*size- voffset		  boxbottom =  min(ylayout +1.5*size + voffset,height-2) //!		  		  		  		  		  boxwidth = boxright-boxleft		  boxheight = boxbottom-boxtop		  		  		  		  top = boxtop		  bottom = boxbottom		  		  		  		  textpattern = newpicture(boxwidth*antix,boxheight*antialiasing,32)		  		  		  boxpicture = newpicture(boxwidth,boxheight,32)		  boxpicture.graphics.useoldRenderer = true		  boxpicture.mask.graphics.useOldRenderer = true		  boxpicture2 = newpicture(boxwidth,boxheight,32)		  boxpicture2.graphics.useOldRenderer = true		  boxpicture2.mask.graphics.useOldRenderer = true		  		  if textpattern=nil or boxpicture = nil or boxpicture2 = nil then		    msgbox "Error Render. Give more memory"		    return		  end		  		  tp=textpattern.graphics		  tp.useOldRenderer = true		  tp.clearrect 0,0,boxwidth,boxheight		  tp.bold = bold		  tp.italic = italic		  tp.underline = underline		  tp.textfont = font		  tp.textsize = antialiasing*size		  tp.penheight = antialiasing*size/12		  tp.forecolor = rgb(0,0,0)		  tp.drawstringWithSpace inn, antix*(xlayout-boxleft),antialiasing* (size + voffset ), antix*spacing, encodingstring		  'if underline then		  'move 0,antialiasing*size/6		  'lineto antix*(xlayout-boxleft),antialiasing*(size+voffset + size/6)		  'end		  tp.drawstringWithSpace in2, antix*(xlayout2-boxleft),antialiasing* ((2*size + leading) + voffset ), antix*spacing, encodingstring		  'if underline and in2<>"" then		  'move 0,antialiasing*size/6		  'lineto antix*(xlayout2-boxleft),antialiasing*(2*size+leading+voffset + size/6)		  'end		  		  		  		  		  app.consolelog "subtitle:render:textpattern end"		  		  		  // drawing rect		  if rectalpha>0 then		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    for rad = rectsoft downto -rectsoft		      'if rectsoft > 0 then		      'ralpha = 255*(1-rectalpha*(rectsoft-rad)/2/rectsoft)		      'else		      ralpha = 255*(1-rectalpha)		      'end		      boxpicture2.mask.graphics.forecolor = rgb(ralpha,ralpha,ralpha)		      boxpicture2.mask.graphics.textfont = font		      boxpicture2.mask.graphics.textsize = size		      theight = boxpicture2.mask.graphics.textheight		      tasc = boxpicture2.mask.graphics.textascent		      tsize = 5 * (boxpicture2.mask.graphics.textsize - tasc)		      tsize = (tsize + 2 * (theight - tsize) )/2		      tsize = gettsize(font,size)		      select case rectform		      case 4		        // not yet supported, because boxpicture varies from title to title		        'boxpicture2.mask.graphics.fillrect xl-boxleft-size/2-rad,voffset-rad,sw/antix+size+2*rad,size + size*1.3+2*rad		        boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height+2*(rad-rectsoft)		      case 3		        // not yet supported, because boxpicture varies from title to title		        'boxpicture2.mask.graphics.fillrect xl-boxleft-size/2-rad,voffset-rad,sw/antix+size+2*rad,size + size*1.3+2*rad		        if sw2>0 or true then		          boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height+2*(rad-rectsoft)		        else		          boxpicture2.mask.graphics.fillrect rectsoft-rad,rectsoft-rad,boxpicture.width+2*(rad-rectsoft),boxpicture.height/2+2*(rad-rectsoft)		        end		      case 1		        sw = max(sw1, sw2)		        xl = min(xlayout, xlayout2)		        if sw2 = 0 then		          boxpicture2.mask.graphics.fillrect xlayout-boxleft-size/2-rad,voffset-rad,sw/antix+size+2*rad,size+tsize+ 2*rad		        else		          boxpicture2.mask.graphics.fillrect xl-boxleft-size/2-rad,voffset-rad,sw/antix+size+2*rad,size + size+leading + tsize+2*rad		          'boxpicture2.mask.graphics.fillrect xlayout-boxleft-size/2-rad,voffset-rad,sw/antix+size+2*rad,size*1.3+2*rad		          'boxpicture2.mask.graphics.fillrect xlayout2-boxleft-size/2-rad,voffset+size+leading-rad,sw/antix+size+2*rad,size*1.3+2*rad		        end		      case 2		        if sw1 > 0 then		          boxpicture2.mask.graphics.fillrect xlayout-boxleft-size/2-rad,voffset-rad,sw1/antix+size+2*rad,size + tsize+2*rad		        end		        if sw2 > 0 then		          boxpicture2.mask.graphics.fillrect xlayout2-boxleft-size/2-rad,voffset+size+leading-rad,sw2/antix+size+2*rad,size+ tsize+2*rad		        end		      end		    next		    		    boxpicture2.graphics.forecolor = rectc		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    g.drawpictureHQ boxpicture2,boxleft,boxtop		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft,boxtop		    		    boxpicture2.graphics.clearrect 0,0,boxwidth,boxheight  // test		    boxpicture2.mask.graphics.forecolor = rgb(0,0,0)		    boxpicture2.mask.graphics.fillrect 0,0,boxwidth,boxheight		  end		  		  app.consolelog "subtitle:render:rect end"		  		  		  // drawing title 		  		  		  if textalpha > 0 then		    		    textpattern.transparent = 0		    boxpicture2.graphics.drawpictureHQ textpattern,0,0,boxwidth,boxheight,0,0,textpattern.width,textpattern.height		    'if textsoft > 0 then		    'soften boxpicture2,textsoft*width/widthreal,textsoft		    'end		    boxpicture.mask.graphics.drawpictureHQ boxpicture2,0,0		    		    boxpicture.graphics.forecolor = rgb(talpha,talpha,talpha)		    boxpicture.graphics.fillrect 0,0,boxwidth,boxheight		    		    boxpicture2.mask.graphics.clearrect 0,0,boxwidth,boxheight		    boxpicture2.mask.graphics.drawpictureHQ boxpicture,0,0		    		    'boxpicture2.graphics.forecolor = textc		    'boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    'g.drawpictureHQ boxpicture2,boxleft,boxtop		    		    // fast		    g.foreColor = textc		    g.fillrect boxleft,boxtop, boxpicture2.width, boxpicture2.height		    		    boxpicture2.graphics.forecolor = rgb(0,0,0)		    boxpicture2.graphics.fillrect 0,0,boxwidth,boxheight		    ga.drawpictureHQ boxpicture2,boxleft,boxtop		  end		  		  		  app.consolelog "subtitle:render:text end"		  		  		  		  		exception err as nilObjectException		  msgBox "Error Subtitle:Render Nil Object Exception"		  		  error = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RenderSmall(st as string,frame as picture, alpha as picture,receiver as eventreceiver)		  dim hscale, vscale as double		  dim l,r,v as avxnumber		  		  if frame = nil then return		  		  hscale = frame.width / width		  vscale = frame.height / height		  		  width = width * hscale		  height  =height * vscale		  bordersoft = bordersoft * vscale		  borderwidth = borderwidth * vscale		  rectsoft = rectsoft * vscale		  shadowsoft = shadowsoft * vscale		  shadowx = shadowx * hscale		  shadowy = shadowy * vscale		  		  size = size * vscale		  spacing = spacing * hscale		  leading = leading * vscale		  		  l = new avxnumber		  l.clone left		  l.value = l.value * hscale		  left =l		  r = new avxnumber		  r.clone right		  r.value = r.value * hscale		  right = r		  v = new avxnumber		  v.clone ver		  v.value = v.value * vscale		  ver = v		  		  		  render st, frame, alpha, receiver		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub restore(inn as memoryblock)		  dim len as integer		  		  if inn.short(2) = 1 and inn.short(0) = 300 then		    //version 1.0		    standard = inn.pstring(16) 		    font = inn.pstring(64)		    size = inn.short(196) 		    		    bold = inttoboolean(inn.short(198) )		    italic = inttoboolean(inn.short(200))		    underline = inttoboolean(inn.short(202))		    ver.value =inn.short(218) 		    halign = inn.short(220) 		    valign = inn.short(222) 		    height = inn.short(240) 		    width = inn.short(242) 		    widthreal = inn.short(244) 		    textc = rgb(inn.byte(256) ,inn.byte(257) ,inn.byte(258) )		    textalpha = inn.short(259)/100		    shadowc = rgb(inn.byte(272) ,inn.byte(273),inn.byte(274))		    shadowalpha = inn.short(275)/100 		    shadowx = inn.short(277) 		    shadowy = inn.short(279)		    antialiasing = inn.short(281)		    left.value = inn.short(283)		    right.value = inn.short(285)		    shadowkind = inn.byte(287)		    wrapmethod=inn.byte(288)		  elseif inn.short(2) = 2 then		    //version 1.1		    len = inn.short(0)		    standard = inn.pstring(16) 		    font = inn.pstring(64)		    size = inn.short(192) 		    leading = inn.short(194)		    spacing = inn.short(196)		    bold = inttoboolean(inn.byte(200) )		    italic = inttoboolean(inn.byte(201))		    underline = inttoboolean(inn.byte(202))		    ver.value =inn.short(224) 		    halign = inn.short(226) 		    valign = inn.short(228) 		    height = inn.short(230) 		    width = inn.short(232) 		    widthreal = inn.short(234)		    antialiasing = inn.short(236)		    left.value = inn.short(238)		    right.value = inn.short(240)		    wrapmethod=inn.short(242)		    interlaced = inttoboolean(inn.byte(244))		    textc = rgb(inn.byte(256) ,inn.byte(257) ,inn.byte(258) )		    textalpha = inn.byte(259)/100		    textsoft = inn.short(260)		    borderc = rgb(inn.byte(272),inn.byte(273),inn.byte(274))		    borderalpha = inn.byte(275)/100		    borderwidth = inn.short(276)		    bordersoft = inn.short(278)		    rectc = rgb(inn.byte(288),inn.byte(289),inn.byte(290))		    rectalpha = inn.byte(291)/100		    rectsoft = inn.short(292)		    shadowc = rgb(inn.byte(304) ,inn.byte(305),inn.byte(306))		    shadowalpha = inn.byte(307)/100 		    shadowx = inn.short(308) 		    shadowy = inn.short(310)		    shadowsoft = inn.short(312)		  else		    MsgBox STStyleReadError		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RestoreFromDict(dict as dictionary)		  dim v as integer		  		  call dict.getstring("font",font)		  call dict.getinteger("size", size)		  call dict.getdouble("spacing", spacing)		  call dict.getdouble("leading", leading)		  call dict.getboolean("bold", bold)		  call dict.getboolean("italic", italic)		  call dict.getboolean("underline", underline)		  		  if dict.getinteger("vertical", v) then ver.value = v		  call dict.getinteger("halin", halign)		  call dict.getinteger("valign", valign)		  		  call dict.getstring("standard", standard)		  call dict.getinteger("height", height)		  call dict.getinteger("width", width)		  call dict.getinteger("widthreal", widthreal)		  call dict.getinteger("antialiasing", antialiasing)		  if dict.getinteger("left", v) then left.value = v		  if dict.getinteger("right", v) then right.value = v		  call dict.getinteger("wrapmethod", wrapmethod)		  call dict.getboolean("interlaced", interlaced)		  		  call dict.getcolor("textcolor", textc)		  call dict.getdouble("textalpha", textalpha)		  call dict.getinteger("textsoft", textsoft)		  		  call dict.getcolor("bordercolor", borderc)		  call dict.getdouble("borderalpha", borderalpha)		  call dict.getinteger("bordersoft", bordersoft)		  call dict.getinteger("borderwidth", borderwidth)		  		  call dict.getcolor("rectcolor", rectc)		  call dict.getdouble("rectalpha", rectalpha)		  call dict.getinteger("rectsoft", rectsoft)		  call dict.getinteger("rectform",rectform)		  		  call dict.getcolor("shadowcolor", shadowc)		  call dict.getdouble("shadowalpha", shadowalpha)		  call dict.getinteger("shadowsoft", shadowsoft)		  call dict.getinteger("shadowx", shadowx)		  call dict.getinteger("shadowy", shadowy)		  		  call dict.getstring("framerate",framerate)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub setstandard(st as string)		  standard = st		  width = 720		  interlaced = true		  antialiasing = 4		  select case st		  case "PAL"		    height = 576		    widthreal = 768		  case "PAL 16:9"		    height = 576		    widthreal = 768*4/3		  case "PAL DVD"		    height = 576		    widthreal = 720		    interlaced = false		  case "NTSC"		    height = 486		    widthreal = 648		  case "NTSC 16:9"		    height = 486		    widthreal = 648*4/3		  case "NTSC DVD"		    height = 480		    widthreal = 720		    interlaced = false		  case "HD 720p"		    height = 720		    width = 1280		    widthreal = 1280		    interlaced = false		  case "HD 720i"		    height = 720		    width = 1280		    widthreal = 1280		    interlaced = true		  case "HD 1080p"		    height = 1080		    width = 1920		    widthreal = 1920		    interlaced = false		  case "2K"		    height = 1080		    width = 2048		    widthreal = 2048		    interlaced = false		  case "2K 1.85"		    height = 1080		    width = 1998		    widthreal = 1998		    interlaced = false		  case "2K 2.35"		    height = 858		    width = 2048		    widthreal = 2048		    interlaced = false		  case "4K"		    height = 2060		    width = 4096		    widthreal = 4096		    interlaced = false		  case "4K 1.85"		    height = 2160		    width = 3996		    widthreal = 3996		    interlaced = false		  case "4K 2.35"		    height = 1716		    width = 4096		    widthreal = 4096		    interlaced = false		  case "HD 1080i"		    height = 1080		    width = 1920		    widthreal = 1920		    interlaced = true		  case "HDV 1080i"		    height = 1080		    width = 1440		    widthreal = 1920		    interlaced = true		  case "NTSC DV"		    height = 480		    widthreal = 648		  case "NTSC 16:9 DV"		    height = 480		    widthreal = 648* 4/3		  case "VGA"		    height = 480		    width = 640		    widthreal = 640		    interlaced = false 		  case "iPod"		    height = 240		    width = 320		    widthreal = 320		    interlaced = false		  case "iPod 16:9"		    height = 180		    width = 320		    widthreal = 320		    interlaced = false		  end select 		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub soften(p as picture, hsoft as integer, vsoft as integer)		  dim map as memoryblock		  dim pw,ph,i,j,ii,jj,test,wsum,pos,val,xsoft,ysoft as integer		  dim surf as rgbSurface		  dim horsoft(-1), versoft(-1), fact as double		  		  pw = p.width		  ph = p.height		  		  xsoft = max(hsoft,1)		  ysoft = max(vsoft,1)		  		  map = newmemoryBlock(2*pw*ph)		  map.littleEndian = false		  if map=nil then		    Msgbox "memory problem. could not soften"		    return		  end		  		  for i = -xsoft to xsoft		    for j = -ysoft to ysoft		      if i*i/xsoft/xsoft +j*j/ysoft/ysoft <= 1 then		        wsum = wsum + 1		      end		    next		  next		  		  surf = p.rgbSurface		  if surf = nil then		    Msgbox "memory problem rgbsurface. could not soften"		    return		  end		  '		  for i= 0 to pw-1		    for j = 0 to ph-1		      test = 255-surf.pixel(i,j).green		      if test > 0 then		        for ii = -xsoft to xsoft		          for jj = -ysoft to ysoft		            if ii*ii/xsoft/xsoft +jj*jj/ysoft/ysoft <= 1 then		              pos = 2*((i+ii)*ph + (j+jj))		              if pos >= 0 and pos < 2*pw*ph then		                map.short(pos) = map.short(pos) + test		              end		            end		          next		        next		      end		    next		  next		  		  for i = 0 to pw-1		    for j = 0 to ph-1		      pos = 2*(i*ph+j)		      val = 255-map.short(pos)/wsum		      if val < 255 then		        surf.pixel(i,j)=rgb(val,val,val)		      end		    next 		  next		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function string2RGBColor(s as string) As color		  dim s2, cs(-1) as string		  s2 = replaceall(s,"(","")		  s2 = replaceall(s2,")","")		  cs = split(s2,",")		  if ubound(cs)>=2 then		    return rgb(val(cs(0)),val(cs(1)),val(cs(2)))		  end		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function stylestring() As string		  dim out,s as string		  dim languagedict as dictionary		  if app.languagedict = nil then		    languagedict = new dictionary		  else		    languagedict = app.languagedict		  end		  out = font + " "+ str(size)+" "		  if bold then		    if languagedict.getstring("bold", s) then 		      out = out + s + " "		    else		      out = out + "bold "		    end		  end		  if italic then		    if languagedict.getstring("italic", s) then 		      out = out + s + " "		    else		      out = out + "italic "		    end		  end		  if underline then		    if languagedict.getstring("underline", s) then 		      out = out + s + " "		    else		      out = out + "underline "		    end		  end		  if languagedict.getstring("color", s) then 		    out = out + s + " "		  else		    out = out + "color"		  end		  out = out + color2rgBString(textc)		  select case halign		  case khalignleft		    if languagedict.getstring("left", s) then 		      out = out + s + " "		    else		      out = out + "left "		    end		  case khaligncenter		    if languagedict.getstring("center", s) then 		      out = out + s + " "		    else		      out = out + "center "		    end		  case khalignright		    if languagedict.getstring("right", s) then 		      out = out + s + " "		    else		      out = out + "right "		    end		  case KHalignCenterLeft		    if languagedict.getstring("centerleft", s) then		      out = out + s + " "		    else		      out = out + "centerleft "		    end		  end		  select case wrapmethod		  case kwrapNone		    if languagedict.getstring("nowrap", s) then 		      out = out + s + " "		    else		      out = out + "no wrap "		    end		  case kwrapsimple		    if languagedict.getstring("simplewrap", s) then 		      out = out + s + " "		    else		      out = out + "simple wrap "		    end		  case kwrapsmart		    if languagedict.getstring("smartwrap", s) then 		      out = out + s + " "		    else		      out = out + "smartwrap "		    end		  end		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Subtitler(s as string)		  Constructor(s)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function TextHeight() As integer		  dim p as picture		  p = newpicture(10,10,32)		  p.graphics.textfont = font		  p.graphics.textsize = size		  return p.graphics.textheight		End Function	#tag EndMethod	#tag Property, Flags = &h0		antialiasing As integer	#tag EndProperty	#tag Property, Flags = &h0		bold As boolean	#tag EndProperty	#tag Property, Flags = &h0		borderalpha As double	#tag EndProperty	#tag Property, Flags = &h0		borderc As color	#tag EndProperty	#tag Property, Flags = &h0		bordersoft As integer	#tag EndProperty	#tag Property, Flags = &h0		borderwidth As integer	#tag EndProperty	#tag Property, Flags = &h0		bottom As integer	#tag EndProperty	#tag Property, Flags = &h21		Private DVDborder As boolean	#tag EndProperty	#tag Property, Flags = &h21		Private DVDtext As boolean	#tag EndProperty	#tag Property, Flags = &h0		error As boolean	#tag EndProperty	#tag Property, Flags = &h0		font As string	#tag EndProperty	#tag Property, Flags = &h0		framerate As string	#tag EndProperty	#tag Property, Flags = &h0		halign As integer	#tag EndProperty	#tag Property, Flags = &h0		height As integer	#tag EndProperty	#tag Property, Flags = &h0		interlaced As boolean	#tag EndProperty	#tag Property, Flags = &h0		italic As boolean	#tag EndProperty	#tag Property, Flags = &h0		leading As double	#tag EndProperty	#tag Property, Flags = &h0		left As avxnumber	#tag EndProperty	#tag Property, Flags = &h0		rectalpha As double	#tag EndProperty	#tag Property, Flags = &h0		rectc As color	#tag EndProperty	#tag Property, Flags = &h0		rectform As integer	#tag EndProperty	#tag Property, Flags = &h0		rectsoft As integer	#tag EndProperty	#tag Property, Flags = &h0		right As avxnumber	#tag EndProperty	#tag Property, Flags = &h0		shadowalpha As double	#tag EndProperty	#tag Property, Flags = &h0		shadowc As color	#tag EndProperty	#tag Property, Flags = &h0		shadowkind As integer	#tag EndProperty	#tag Property, Flags = &h0		shadowsoft As integer	#tag EndProperty	#tag Property, Flags = &h0		shadowx As integer	#tag EndProperty	#tag Property, Flags = &h0		shadowy As integer	#tag EndProperty	#tag Property, Flags = &h0		size As integer	#tag EndProperty	#tag Property, Flags = &h0		spacing As double	#tag EndProperty	#tag Property, Flags = &h0		standard As string	#tag EndProperty	#tag Property, Flags = &h0		textalpha As double	#tag EndProperty	#tag Property, Flags = &h0		textc As color	#tag EndProperty	#tag Property, Flags = &h0		textsoft As integer	#tag EndProperty	#tag Property, Flags = &h0		top As integer	#tag EndProperty	#tag Property, Flags = &h0		underline As boolean	#tag EndProperty	#tag Property, Flags = &h0		valign As integer	#tag EndProperty	#tag Property, Flags = &h0		ver As avxnumber	#tag EndProperty	#tag Property, Flags = &h0		width As integer	#tag EndProperty	#tag Property, Flags = &h0		widthreal As integer	#tag EndProperty	#tag Property, Flags = &h0		wrapgraphics As graphics	#tag EndProperty	#tag Property, Flags = &h0		wrapmethod As integer	#tag EndProperty	#tag Property, Flags = &h0		wrappicture As picture	#tag EndProperty	#tag Constant, Name = kHalignCenter, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = KHalignCenterLeft, Type = Double, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag Constant, Name = kHalignLeft, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kHalignRight, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = kValignBottom, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = kValignCenter, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kValignTop, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kWrapNone, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kWrapSimple, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kWrapSmart, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="antialiasing"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="bold"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="borderalpha"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="borderc"			Group="Behavior"			InitialValue="&h000000"			Type="color"		#tag EndViewProperty		#tag ViewProperty			Name="bordersoft"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="borderwidth"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="bottom"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="error"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="font"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="framerate"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="halign"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="height"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="interlaced"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="italic"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="leading"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="rectalpha"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="rectc"			Group="Behavior"			InitialValue="&h000000"			Type="color"		#tag EndViewProperty		#tag ViewProperty			Name="rectform"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="rectsoft"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="shadowalpha"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="shadowc"			Group="Behavior"			InitialValue="&h000000"			Type="color"		#tag EndViewProperty		#tag ViewProperty			Name="shadowkind"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="shadowsoft"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="shadowx"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="shadowy"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="size"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="spacing"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="standard"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="textalpha"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="textc"			Group="Behavior"			InitialValue="&h000000"			Type="color"		#tag EndViewProperty		#tag ViewProperty			Name="textsoft"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="underline"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="valign"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="width"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="widthreal"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="wrapmethod"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="wrappicture"			Group="Behavior"			InitialValue="0"			Type="picture"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass