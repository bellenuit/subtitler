#tag ModuleProtected Module ImageTransformations	#tag Method, Flags = &h0		Function Convolution(extends p as picture, hor() as double, ver() as double, channels as integer) As picture		  dim p2, intermediate, result as picture		  dim insurf,intermediatesurf, outsurf as rgbSurface		  dim x,y,r,g,b,w,h,r2,g2,b2,i,ub as integer		  dim start, ende as integer		  dim c as color		  		  'return p.convolutionaltivec(hor,ver,channels)		  		  if p=nil then return nil		  		  // verify if picture has an rgbsurface		  insurf = p.rgbSurface		  if insurf = nil then		    p2 = newpicture(p.width,p.height,32)		    if p2<>nil then		      p2.graphics.drawpicture p,0,0		      insurf = p2.rgbSurface		    end		  end		  		  intermediate = newpicture(p.width,p.height,32)		  if intermediate<>nil then		    intermediatesurf = intermediate.rgbSurface		  end		  		  result = newpicture(p.width,p.height,32)		  if result<>nil then		    outsurf = result.rgbSurface		  end		  		  if insurf = nil or intermediatesurf = nil or outsurf = nil then		    return nil		  end		  		  w = p.width-1		  h = p.height-1		  		  // borders will not be treated. if somebody want to get until the border, he can provide a larger picture.		  		  ub = ubound(hor)		  start = ub / 2		  ende = w-1 - ub / 2		  		  for x = start to ende		    for y = 0 to h		      if bitwiseand(channels,1) = 1 then		        r = 0		        for i = 0 to ub		          r = r + insurf.pixel(x+i-ub/2,y).red * hor(i)		        next		      else		        r = insurf.pixel(x,y).red		      end		      if bitwiseand(channels,2) = 2 then		        g = 0		        for i = 0 to ub		          g = g + insurf.pixel(x+i-ub/2,y).green * hor(i)		        next		      else		        g = insurf.pixel(x,y).green		      end		      if bitwiseand(channels,4) = 4 then		        b = 0		        for i = 0 to ub		          b = b + insurf.pixel(x+i-ub/2,y).blue * hor(i)		        next		      else		        b = insurf.pixel(x,y).blue		      end		      intermediatesurf.pixel(x,y) = rgb(r,g,b)		    next		  next		  		  ub = ubound(ver)		  start = ub / 2		  ende = h-1 - ub / 2		  		  for x = 0 to w		    for y = start to ende		      if bitwiseand(channels,1) = 1 then		        r = 0		        for i = 0 to ub		          r = r + intermediatesurf.pixel(x,y+i-ub/2).red * ver(i)		        next		      else		        r = intermediatesurf.pixel(x,y).red		      end		      if bitwiseand(channels,2)= 2 then		        g = 0		        for i = 0 to ub		          g = g + intermediatesurf.pixel(x,y+i-ub/2).green * ver(i)		        next		      else		        g = intermediatesurf.pixel(x,y).green		      end		      if bitwiseand(channels,4)= 4 then		        b = 0		        for i = 0 to ub		          b = b + intermediatesurf.pixel(x,y+i-ub/2).blue * ver(i)		        next		      else		        b = intermediatesurf.pixel(x,y).blue		      end		      outsurf.pixel(x,y) = rgb(r,g,b)		    next		  next		  return result		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function LUT3d(extends p as picture, lut(,,,) as double) As picture		  dim p2, result as picture		  dim insurf,outsurf as rgbSurface		  dim x,y,r,g,b,w,h,r2,g2,b2 as integer		  dim nx,ny,nz,nx1,ny1,nz1,i,sxyz as integer		  dim fx,fy,fz as double		  dim c as color		  		  		  // expects a LUT(16,16,16,2), eg 17 values in each dimension, which makes even steps from 0..15.30..255		  		  if p=nil then return nil		  		  // verify if picture has an rgbsurface		  insurf = p.rgbSurface		  if insurf = nil then		    p2 = newpicture(p.width,p.height,32)		    if p2<>nil then		      p2.graphics.drawpicture p,0,0		      insurf = p2.rgbSurface		    end		  end		  		  result = newpicture(p.width,p.height,32)		  if result<>nil then		    outsurf = result.rgbSurface		  end		  		  if insurf = nil or outsurf = nil then		    return nil		  end		  		  w = p.width-1		  h = p.height-1		  		  for y = 0 to h		    for x = 0 to w		      c = insurf.Pixel(x,y)		      r = c.red		      g = c.green		      b = c.blue		      		      nx = r \ 17		      ny = g \ 17		      nz = b \ 17		      		      nx1 = min(nx+1,15)  		      ny1 = min(ny+1,15)  		      nz1 = min(nz+1,15) 		      		      fx = (r mod 17) / 17.0		      fy = (g mod 17) / 17.0		      fz = (b mod 17) / 17.0		      		      		      for i = 0 to 2		        // tetraeder interpolation.		        // would probably be faster if each channel coded  and not a for-loop		        		        if (fx > fy) then		          if (fy > fz) then		            Sxyz = (1.0-fx)* LUT( nx , ny , nz, i ) + (fx-fy)* LUT(nx1, ny , nz, i ) + (fy-fz)* LUT(nx1,ny1, nz, i ) + (fz)* LUT(nx1,ny1,nz1,i)		          elseif (fx > fz) then		            Sxyz = (1.0-fx)* LUT( nx , ny , nz, i ) + (fx-fz)* LUT(nx1, ny , nz, i ) + (fz-fy)* LUT(nx1, ny ,nz1, i) + (fy)* LUT(nx1,ny1,nz1,i)		          else 		            Sxyz = (1.0-fz)* LUT( nx , ny , nz, i) + (fz-fx)* LUT( nx , ny ,nz1, i) + (fx-fy)* LUT(nx1, ny ,nz1,i)+ (fy)* LUT(nx1,ny1,nz1,i)		          end		        else 		          if (fz > fy) then		            Sxyz = (1.0-fz)* LUT( nx , ny , nz,i ) + (fz-fy)* LUT( nx , ny ,nz1,i) + (fy-fx)* LUT( nx ,ny1,nz1,i) + (fx)* LUT(nx1,ny1,nz1,i)		          elseif (fz > fx) then		            Sxyz = (1.0-fy)* LUT( nx , ny , nz,i ) + (fy-fz)* LUT( nx ,ny1, nz ,i) + (fz-fx)* LUT( nx ,ny1,nz1,i) + (fx)* LUT(nx1,ny1,nz1,i)		          else 		            Sxyz = (1.0-fy)* LUT( nx , ny , nz,i ) + (fy-fx)* LUT( nx ,ny1, nz ,i) + (fx-fz)* LUT(nx1,ny1, nz ,i) + (fz)* LUT(nx1,ny1,nz1,i)		          end		        end		        		        select case i		        case 0		          r = Sxyz		        case 1		          g = Sxyz		        case 2		          b = Sxyz		        end		        		      next		      		      outsurf.pixel(x,y) = rgb(r,g,b)		    next		    		  next		  		  		  return result		  		exception err as outofboundsException		  		  msgBox "matrix too small"		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Matrix3d(extends p as picture, m(,) as double) As picture		  dim p2, result as picture		  dim insurf,outsurf as rgbSurface		  dim x,y,r,g,b,w,h,r2,g2,b2 as integer		  dim c as color		  		  if p=nil then return nil		  		  // verify if picture has an rgbsurface		  insurf = p.rgbSurface		  if insurf = nil then		    p2 = newpicture(p.width,p.height,32)		    if p2<>nil then		      p2.graphics.drawpicture p,0,0		      insurf = p2.rgbSurface		    end		  end		  		  result = newpicture(p.width,p.height,32)		  if result<>nil then		    outsurf = result.rgbSurface		  end		  		  if insurf = nil or outsurf = nil then		    return nil		  end		  		  w = p.width-1		  h = p.height-1		  		  for x = 0 to w		    for y = 0 to h		      c = insurf.pixel(x,y)		      r = c.red		      g = c.green		      b = c.blue		      		      r2 = m(0,0)*r + m(1,0)*g + m(2,0)*b		      g2 = m(0,1)*r + m(1,1)*g + m(2,1)*b		      b2 = m(0,2)*r + m(1,2)*g + m(2,2)*b		      		      outsurf.pixel(x,y) = rgb(r2,g2,b2)		    next		  next		  		  return result		  		exception err as outofboundsException		  		  msgBox "matrix too small"		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Matrix3dwithConstants(extends p as picture, m(,) as double) As picture		  dim p2, result as picture		  dim insurf,outsurf as rgbSurface		  dim x,y,r,g,b,w,h,r2,g2,b2 as integer		  dim c as color		  		  if p=nil then return nil		  		  // verify if picture has an rgbsurface		  insurf = p.rgbSurface		  if insurf = nil then		    p2 = newpicture(p.width,p.height,32)		    if p2<>nil then		      p2.graphics.drawpicture p,0,0		      insurf = p2.rgbSurface		    end		  end		  		  result = newpicture(p.width,p.height,32)		  if result<>nil then		    outsurf = result.rgbSurface		  end		  		  if insurf = nil or outsurf = nil then		    return nil		  end		  		  w = p.width-1		  h = p.height-1		  		  for x = 0 to w		    for y = 0 to h		      c = insurf.pixel(x,y)		      r = c.red + m(3,0)		      g = c.green + m(3,1)		      b = c.blue + m(3,2)		      		      r2 = m(0,0)*r + m(1,0)*g + m(2,0)*b + m(0,3)		      g2 = m(0,1)*r + m(1,1)*g + m(2,1)*b + m(1,3)		      b2 = m(0,2)*r + m(1,2)*g + m(2,2)*b + m(2,3)		      		      outsurf.pixel(x,y) = rgb(r2,g2,b2)		    next		  next		  		  return result		  		exception err as outofboundsException		  		  msgBox "matrix too small"		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function RunLengthDecode(extends m as memoryBlock) As memoryBlock		  // must be dynamically resized. we start with 2 times the length		  		  dim i,j as integer		  dim count as integer		  dim test,b as integer		  dim st as string		  dim run as boolean		  dim moffset, resultoffset as integer		  dim result as memoryBlock		  dim s as integer		  		  result = newmemoryBlock(m.size*2)		  result.littleEndian = false		  		  		  //Loop until you get the number of unpacked bytes you are expecting:		  //  Read the next source byte into n.		  //  If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.		  // Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.		  //Else if n is -128, noop.		  // Endloop		  		  //-127 signed char is 129 unsigned char		  		  s = m.size		  		  for i = 0 to s-1		    test = m.byte(moffset)		    moffset = moffset + 1		    if test>=0 and test<=127 then		      st = m.stringValue(moffset,test+1)		      moffset = moffset + test + 1		      		      if result.size < resultoffset + test + 1 then		        result.size = resultoffset + test + 1		      end		      result.stringValue(resultoffset,test+1) = st		      resultoffset = resultoffset + test + 1		      		    elseif test = 128 then		      // nop		    else		      test = test - 256 // make signed		      b = m.byte(moffset)		      moffset = moffset + 1		      		      if result.size < resultoffset - test + 1 then		        result.size = resultoffset - test + 1		      end		      for j = 1 to -test + 1 		        result.byte(resultoffset) = b		        resultoffset = resultoffset + 1		      next		    end		    i = moffset		  next		  result.size = resultoffset		  return result		  		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function RunLengthEncode(extends m as memoryBlock) As memoryBlock		  // Decode:		  //Loop until you get the number of unpacked bytes you are expecting:		  //  Read the next source byte into n.		  //  If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.		  // Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.		  //Else if n is -128, noop.		  // Endloop		  		  //-127 signed char is 129 unsigned char		  		  // worst case: result is 128/127 + 1 byte longer		  		  dim i as integer		  dim count as integer		  dim test,old,oldold as integer		  dim st as string		  dim run as boolean		  dim moffset, resultoffset as integer		  dim result as memoryBlock		  dim s as integer		  		  result = newmemoryBlock(m.size*128/127+1)		  result.littleEndian = false		  		  //test with declare		  		  		  // this is a toolbox function in mac, but i never got it working.		  'dim memIn,memOut  as memoryblock		  '		  'if s = 0 then		  'return		  'end		  '		  'memIn = newmemoryBlock(s)		  'for i = 0 to s-1		  'memin.byte(i) = m.readbyte		  'next		  'memOut = newmemoryBlock(s+(s+126)/127)		  '		  'Declare Sub PackBits Lib "InterfaceLib" (srcPtr as Ptr, dstPtr as Ptr, srcBytes as Integer)		  '		  'PackBits memIn,memOut,s		  '		  'for i = 0 to s+(s+126)/127-1		  '		  'next		  '		  'return		  		  test=-1		  old = -1		  oldold=-1		  count = -1		  run = false		  st=""		  s = m.size		  for i = 0 to s-1		    test = m.byte(moffset)		    moffset = moffset + 1		    if run then		      if test = old then		        count = count -1		        if count = 129  then		          result.byte(resultoffset) = count		          resultoffset = resultoffset + 1		          result.byte(resultoffset) = test		          resultoffset = resultoffset + 1		          run = false		          test = -1		          count = -1		          st = ""		        end if		      else		        result.byte(resultoffset) = count		        resultoffset = resultoffset + 1		        result.byte(resultoffset) = old		        resultoffset = resultoffset + 1		        run = false		        count = 0		        st =chrb(test)		      end if		    else		      if test = old and test = oldold then		        if count > 1 then		          result.byte(resultoffset) = count-2		          resultoffset = resultoffset + 1		          result.stringvalue(resultoffset,lenb(st)) = st		          resultoffset = resultoffset + lenb(st)		          resultoffset = resultoffset - 2 // last 2 bytes are wrong		        end if		        run = true		        count = 254		        st =""		      else		        st = st + chrb(test)		        count = count + 1		        if count = 127 then		          result.byte(resultoffset) = count		          resultoffset = resultoffset + 1		          result.stringvalue(resultoffset,lenb(st)) = st		          resultoffset = resultoffset + lenb(st)		          run = false		          test = -1		          count = -1		          st = ""		        end if		      end if		    end if		    oldold = old		    old = test		    		  next		  if count >-1 then		    if run then		      result.byte(resultoffset) = count		      resultoffset = resultoffset + 1		      result.byte(resultoffset) = test		      resultoffset = resultoffset + 1		    else		      result.byte(resultoffset) = count		      resultoffset = resultoffset + 1		      result.stringvalue(resultoffset,lenb(st)) = st		      resultoffset = resultoffset + lenb(st)		    end if		  end if		  result.size = resultoffset		  return result		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Unmultiply(extends p as picture) As picture		  dim p2, maskpicture, result as picture		  dim insurf,masksurf,outsurf as rgbSurface		  dim x,y,r,g,b,m,w,h as integer		  dim c as color		  		  if p=nil then return nil		  		  // verify if picture has an rgbsurface		  insurf = p.rgbSurface		  if insurf = nil then		    p2 = newpicture(p.width,p.height,32)		    if p2<>nil then		      p2.graphics.drawpicture p,0,0		      insurf = p2.rgbSurface		    end		  else		    p2 = p		  end		  		  maskpicture = p2.mask		  masksurf = maskpicture.rgbsurface		  		  result = newpicture(p.width,p.height,32)		  if result<>nil then		    outsurf = result.rgbSurface		  end		  		  if insurf = nil or masksurf = nil or  outsurf = nil then		    return nil		  end		  		  w = p.width-1		  h = p.height-1		  		  for x = 0 to w		    for y = 0 to h		      c = insurf.pixel(x,y)		      r = c.red		      g = c.green		      b = c.blue		      m = 255-masksurf.pixel(x,y).green		      		      if m > 0 then		        r = r * 255 / m		        g = g * 255 / m		        b = b * 255 / m		      end		      		      outsurf.pixel(x,y) = rgb(r,g,b)		    next		  next		  		  result.mask.graphics.drawpicture maskpicture,0,0		  		  return result		  		  		End Function	#tag EndMethod	#tag Note, Name = altivec		these function would probably profit from altivec, if values are converted to single.		the vdsp library has a convolution function.					#tag EndNote	#tag Note, Name = c++ code for demultiply		static REALpicture DeMultiplyMethod(REALpicture p, REALpicture a)		{		 		 REALpictureDescription pdesc;		 REALLockPictureDescription(p, &pdesc);		 if (pdesc.pictureType != pictureMacintoshGWorld) 		 {		  return NULL;		 }		 		 REALpictureDescription adesc;		 REALLockPictureDescription(a, &adesc);		 if (adesc.pictureType != pictureMacintoshGWorld) 		 {		  REALUnlockPictureDescription(p);		  return NULL;		 }		  		 REALpicture result = REALNewPicture(pdesc.width,pdesc.height,32);		 REALpictureDescription resultdesc;		 REALLockPictureDescription(result, &resultdesc);		 if (!result)		 { 		  REALUnlockPictureDescription(p);		  REALUnlockPictureDescription(a);		  return NULL;		 }		 		 GWorldPtr pworld = (GWorldPtr)pdesc.pictureData;		 PixMapHandle ppm = GetGWorldPixMap (pworld);		 long rowb = GetPixRowBytes(ppm);		 Ptr pgp = GetPixBaseAddr (ppm);		 		 GWorldPtr aworld = (GWorldPtr)adesc.pictureData;		 PixMapHandle apm = GetGWorldPixMap (aworld);		 Ptr agp = GetPixBaseAddr (apm);		 		 GWorldPtr resultworld = (GWorldPtr)resultdesc.pictureData;		 PixMapHandle resultpm = GetGWorldPixMap (resultworld);		 Ptr resultgp = GetPixBaseAddr (resultpm);		 		 // now we have simple pointers		 		 int width = pdesc.width;		 int height = pdesc.height;		 int channels = 4;		   		 for (int y = 0; y < height; y++)		 {		  unsigned char * linein = (unsigned char *)pgp + (y*rowb);		  unsigned char * linealpha = (unsigned char *)agp + (y*rowb) + 2 ; // green channel;		  unsigned char * lineout = (unsigned char *)resultgp + (y*rowb);		    		  for (int x = 0; x < width; x++)		  {		   int al = *linealpha;		   linealpha += channels;		   		   for (int c = 0; c < channels; c++)		   {		    if (al < 255 && c > 0)		    {		     *(lineout++) =  *linein * 255 / ( 255 - al );		    }		    else		    {		     *(lineout++) = 0;		    }		    		    linein++;		   }		      		  }		 }		 		 				 REALUnlockPictureDescription(p);		 REALUnlockPictureDescription(a);		 return result;		  		}					#tag EndNote	#tag Note, Name = c++ code for LUT3d		// lut is provided here as picture, but an array may be more appropriate				static REALpicture CLUTMethod(REALpicture p, REALpicture a)		{		 		 REALpictureDescription pdesc;		 REALLockPictureDescription(p, &pdesc);		 if (pdesc.pictureType != pictureMacintoshGWorld) 		 {		  return NULL;		 }		 		 REALpictureDescription adesc;		 REALLockPictureDescription(a, &adesc);		 if (adesc.pictureType != pictureMacintoshGWorld) 		 {		  REALUnlockPictureDescription(p);		  return NULL;		 }		  		 REALpicture result = REALNewPicture(pdesc.width,pdesc.height,32);		 REALpictureDescription resultdesc;		 REALLockPictureDescription(result, &resultdesc);		 if (!result)		 { 		  REALUnlockPictureDescription(p);		  REALUnlockPictureDescription(a);		  return NULL;		 }		 		 GWorldPtr pworld = (GWorldPtr)pdesc.pictureData;		 PixMapHandle ppm = GetGWorldPixMap (pworld);		 long rowb = GetPixRowBytes(ppm);		 Ptr pgp = GetPixBaseAddr (ppm);		 		 GWorldPtr aworld = (GWorldPtr)adesc.pictureData;		 PixMapHandle apm = GetGWorldPixMap (aworld);		 long rowba = GetPixRowBytes(apm);		 Ptr agp = GetPixBaseAddr (apm);		 		 GWorldPtr resultworld = (GWorldPtr)resultdesc.pictureData;		 PixMapHandle resultpm = GetGWorldPixMap (resultworld);		 Ptr resultgp = GetPixBaseAddr (resultpm);		 		 // now we have simple pointers		 		 		 float CLUT[17][17][17][3];		 		 // fill CLUT		 int channels = 4;		 int width = adesc.width;		 int height = adesc.height;		 		 if (width == 64 && height == 64)		 {		  for (int r = 0; r < 17; r++)		  {		   int rr = r; if (rr == 16) rr = 15;		   		   for (int g = 0; g < 17; g++)		   {		    int gg = g; if (gg == 16) gg = 15;		    		    for (int b = 0; b < 17; b++)		    {		     int bb = b; if (bb == 16) bb = 15;		     		     int x = bb + 16*(gg / 4);		           int y = 15-rr + 16*(gg % 4);		           		           unsigned char *thepixel = (unsigned char *)agp + y*rowba + x*channels;		           thepixel++; // 32bit ARGB		     CLUT[r][g][b][0] = *(thepixel++);		     CLUT[r][g][b][1] = *(thepixel++);		     CLUT[r][g][b][2] = *(thepixel);		    }		   }		  }		 }		 else		 {		  for (int r = 0; r < 17; r++)		  {		   for (int g = 0; g < 17; g++)		   {		    for (int b = 0; b < 17; b++)		    {		     CLUT[r][g][b][0] = r*17;		     CLUT[r][g][b][1] = g*17;		     CLUT[r][g][b][2] = b*17;		    }		   }		  }		 }		 		 		 		 width = pdesc.width;		 height = pdesc.height;		   		 for (int y = 0; y < height; y++)		 {		  unsigned char * linein = (unsigned char *)pgp + (y*rowb);		  unsigned char * lineout = (unsigned char *)resultgp + (y*rowb);		    		  for (int x = 0; x < width; x++)		  {		   linein++; // 32 bit ARGB		   int r = *(linein++);		   int g = *(linein++);		   int b = *(linein++);		   		   lineout++;  // 32bit ARGB		   		   for (int c = 0; c < 3;  c++)		   {		    int nx=r / 17;		    int ny=g / 17;		    int nz=b / 17;		    float fx=(r % 17 ) / 17.0;		    float fy=(g % 17 ) / 17.0;		    float fz=(b % 17 ) / 17.0;		    float Sxyz;		    if (fx > fy) 		    {		     if (fy > fz) 		     {		      Sxyz = (1-fx)* CLUT[ nx ][ ny ][ nz ][c]		      + (fx-fy)* CLUT[nx+1][ ny ][ nz ][c]		      + (fy-fz)* CLUT[nx+1][ny+1][ nz ][c]		      + (fz)* CLUT[nx+1][ny+1][nz+1][c];		     } 		     else if (fx > fz) 		     {		      Sxyz = (1-fx)* CLUT[ nx ][ ny ][ nz ][c]		      + (fx-fz)* CLUT[nx+1][ ny ][ nz ][c]		      + (fz-fy)* CLUT[nx+1][ ny ][nz+1][c]		      + (fy)* CLUT[nx+1][ny+1][nz+1][c];		     } 		     else 		     {		      Sxyz = (1-fz)* CLUT[ nx ][ ny ][ nz ][c]		      + (fz-fx)* CLUT[ nx ][ ny ][nz+1][c]		      + (fx-fy)* CLUT[nx+1][ ny ][nz+1][c]		      + (fy)* CLUT[nx+1][ny+1][nz+1][c];		     }		    } 		    else 		    {		     if (fz > fy) 		     {		      Sxyz = (1-fz)* CLUT[ nx ][ ny ][ nz ][c]		      + (fz-fy)* CLUT[ nx ][ ny ][nz+1][c]		      + (fy-fx)* CLUT[ nx ][ny+1][nz+1][c]		      + (fx)* CLUT[nx+1][ny+1][nz+1][c];		     } 		     else if (fz > fx) 		     {		      Sxyz = (1-fy)* CLUT[ nx ][ ny ][ nz ][c]		      + (fy-fz)* CLUT[ nx ][ny+1][ nz ][c]		      + (fz-fx)* CLUT[ nx ][ny+1][nz+1][c]		      + (fx)* CLUT[nx+1][ny+1][nz+1][c];		     } 		     else 		     {		      Sxyz = (1-fy)* CLUT[ nx ][ ny ][ nz ][c]		      + (fy-fx)* CLUT[ nx ][ny+1][ nz ][c]		      + (fx-fz)* CLUT[nx+1][ny+1][ nz ][c]		      + (fz)* CLUT[nx+1][ny+1][nz+1][c];		     }		    }		    		    *(lineout++) = Sxyz;		    		   }		   		   		   		      		  }		 }		 		 				 REALUnlockPictureDescription(p);		 REALUnlockPictureDescription(a);		 return result;		  		}					#tag EndNote	#tag Note, Name = going further		8bit pictures are limited for professional use.		a support for a 16bit or floating point picture type would be very interesting.		read and write from file streams and 10bit log filestreams.		write to RB 8bit pictures		access to pixels.		and the same matrix, LUT and transformation functions we have on the normal pictures		support for graphics.methods							#tag EndNote	#tag Note, Name = RLE packbits		RLE code packbits is formally a toolbox call, i do not know if it still exists in carbon.		i never got it work, it crashed. (probably, you can only send him little chunks < 1024 bytes).		anyway, you may also have the source code in the tiff library, because it's one compression, tiff supports. 		packbits is not very interesting for real images, but for graphics, it is very effective and still losless.					#tag EndNote	#tag Note, Name = why LUT3d		3d LUT is provided in the ICC specifications and in colorsync, but the XYZ-umweg is so weird, i cannot get it work.		with a 3d LUT you can modelise very complex color corrections with great accuracy and a minumum of amount of calculation.		you only calculate the correction on the LUT3d and then apply to big pictures.		it is also the only way in complex calibration situations, where you cannot modelise it mathematically			#tag EndNote	#tag Note, Name = why matrix with constants		you need to be able to add constants to compensate for black levels and to allow for negative.		it makes the matrix only a bit larger.							#tag EndNote	#tag Note, Name = why unmultiply		you composite a picture which is later to be composited on another picture not yet present.		if you composite in RB, the picture is premultiplied and you get jaggy edges when you composite it again with 		the mask.		the solution is to unmultiply.			#tag EndNote	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Module#tag EndModule