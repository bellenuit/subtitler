#tag ClassProtected Class RAMstream	#tag Method, Flags = &h0		Function About() As String		  return "RAMStream by Matthias BÃ¼rcher"		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(size as integer, chunk as integer=1)		  		  streamP = NewMemoryBlock(size)		  streamp.LittleEndian = false		  		  if streamP = nil then		    errorP = true		  else		    lengthP = size		    chunkP = chunk		    errorP = false		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function EOF() As boolean		  return (positionP >= lengthP)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Error() As boolean		  return errorP		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Length() As integer		  return lengthP		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function littleendian() As boolean		  return streamp.LittleEndian		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub littleendian(value as boolean)		  streamp.LittleEndian = value		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Methods() As string		  dim out as string		  out = "Function About() As String"+chr(13)		  out = out +"Function EOF() As boolean"+chr(13)		  out = out +"Function Error() as boolean"+chr(13)		  out = out +"Function Length() As integer"+chr(13)		  out = out +"Function Methods() As string"+chr(13)		  out=out+"Function Position() as integer"+chr(13)		  out=out+"Sub Position(pos as integer)"+chr(13)		  out = out +"Function Properties() as string"+chr(13)		  out = out +"Sub RAMStream(size as integer)"+chr(13)		  out = out +"Sub RAMStream(size as integer, chunk as integer)"+chr(13)		  out = out +"Function Read(count as integer) As string"+chr(13)		  out = out +"Function ReadAll() As string"+chr(13)		  out = out +"Function ReadBoolean() As boolean"+chr(13)		  out = out +"Function ReadByte() As integer"+chr(13)		  out = out +"Function ReadColor() As color"+chr(13)		  out = out +"Function ReadLong() As integer"+chr(13)		  out = out +"Function ReadLongString() As string"+chr(13)		  out = out +"Function ReadPString() As string"+chr(13)		  out = out +"Function ReadShort() As integer"+chr(13)		  out = out + "Function ReadSingle() As double" + chr(13)		  out = out +"Sub Resize(size as integer)"+chr(13)		  out = out + "Function Version() As string"+chr(13)		  out = out + "Sub Write(data as string)"+chr(13)		  out = out +"Sub WriteBoolean(value as boolean)"+chr(13)		  out = out +"Sub WriteByte(value as integer)"+chr(13)		  out = out +"Sub WriteColor(value as color)"+chr(13)		  out = out +"Sub WriteLong(value as integer)"+chr(13)		  out = out +"Sub WriteLongString(text as string)"+chr(13)		  out = out +"Sub WritePString(text as string)"+chr(13)		  out = out +"Sub WriteShort(value as integer)"+chr(13)		  out = out +"Sub WriteSingle(value as double)"+chr(13)		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Position() As integer		  return positionP		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Position(pos as integer)		  if pos < 0 then		    positionP = 0		  elseif pos > lengthP then		    positionP = lengthP		  else		    positionP = pos		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Properties() As string		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read(count as integer) As string		  dim i as integer		  dim out as string		  dim exp as OutOfBoundsException		  if positionP + count > lengthP then		    raise exp		  end		  		  out = streamp.StringValue(positionP,count)		  return out		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadAll() As string		  dim pos as integer		  dim s as string		  pos = positionP		  positionP = 0		  s = read(length)		  positionP = pos		  return s		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadBoolean() As boolean		  dim test as integer		  test = ReadByte		  return (test=1)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadByte() As integer		  dim out as integer		  dim exp as OutOfBoundsException		  if positionP +1 > lengthP then		    raise exp		  end		  out = streamP.byte(positionP)		  positionP = positionP+1		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadColor() As color		  dim a, r,g,b as integer		  a = ReadByte		  r = ReadByte		  g = ReadByte		  b = ReadByte		  return RGB(r,g,b)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadLong() As integer		  dim out as integer		  dim exp as OutOfBoundsException		  if positionP + 4 > lengthP then		    raise exp		  end		  out = streamP.long(positionP)		  positionP = positionP+4		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadLongString() As String		  dim count as integer		  dim out as string		  count = ReadLong		  out = Read(count)		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadPString() As string		  dim count, i as integer		  dim out as string		  count = ReadByte		  out = Read(count)		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadShort() As integer		  dim i as integer		  dim out as integer		  dim exp as OutOfBoundsException		  if positionP + 2 > lengthP then		    raise exp		  end		  out = streamP.short(positionP)		  positionP = positionP+2		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadSingle() As double		  dim i as integer		  dim out as integer		  dim exp as OutOfBoundsException		  if positionP + 4 >= lengthP then		    raise exp		  end		  out = streamP.singlevalue(positionP)		  positionP = positionP+4		  return out		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Resize(size as integer)		  dim m as Memoryblock		  dim i as integer		  		  m = newmemoryblock(ceil(size/chunkp)*chunkp)		  		  if m = nil then		    errorP = true		    return		  else		    for i = 0 to lengthP-1		      m.byte(i) = streamP.byte(i)		    next		    streamP = m		    lengthP = size		    errorP = false		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Version() As string		  return "1.2"		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Write(data as string)		  dim i,l as integer		  if errorP then		    return		  end		  l = len(data)		  if positionP + l >= lengthP then		    resize positionP+l		    lengthP = positionP+l		  end		  for i = 0 to l-1		    streamP.byte(positionP+i)=asc(mid(data,i+1,1))		  next		  positionP = positionP+l		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteBoolean(value as boolean)		  if errorP then		    return		  end		  if value then		    writebyte 1		  else		    writebyte 0		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteByte(value as integer)		  if errorP then		    return		  end		  if positionP + 1 >= lengthP then		    resize positionP+1		    lengthP = positionP+1		  end		  streamP.byte(positionP)=value		  positionP = positionP+1		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteColor(c as color)		  if errorP then		    return		  end		  writebyte 0		  writebyte c.red		  writebyte c.green		  writebyte c.blue		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteLong(value as integer)		  if errorP then		    return		  end		  if positionP + 4 >= lengthP then		    resize positionP+4		    lengthP = positionP+4		  end		  streamP.long(positionP)=value		  positionP = positionP+4		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteLongString(text as string)		  if errorP then		    return		  end		  writelong len(text)		  write text		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WritePString(text as string)		  dim shorttext as string		  if errorP then		    return		  end		  if len(text) > 255 then		    shorttext = left(text,255)		  else		    shorttext = text		  end		  writebyte len(shorttext)		  write shorttext		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteShort(value as integer)		  if errorP then		    return		  end		  if positionP + 2 >= lengthP then		    resize positionP+2		    lengthP = positionP+2		  end		  streamP.short(positionP)=value		  positionP = positionP+2		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteSingle(value as double)		  if errorP then		    return		  end		  if positionP + 4 >= lengthP then		    resize positionP+4		    lengthP = positionP+4		  end		  streamP.singlevalue(positionP)=value		  positionP = positionP+4		  		  		End Sub	#tag EndMethod	#tag Property, Flags = &h1		Protected chunkP As integer	#tag EndProperty	#tag Property, Flags = &h0		errorP As boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected lengthP As integer	#tag EndProperty	#tag Property, Flags = &h0		littleendian As boolean	#tag EndProperty	#tag Property, Flags = &h0		positionP As integer	#tag EndProperty	#tag Property, Flags = &h1		Protected streamP As memoryblock	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="errorP"			Group="Behavior"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="littleendian"			Group="Behavior"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="positionP"			Group="Behavior"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass