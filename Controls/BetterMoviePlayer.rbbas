#tag ClassProtected Class BetterMoviePlayerInherits MoviePlayer	#tag Event		Sub Stop()		  self.PlaySelection = false		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub AddInterestingPoint(value as double)		  dim i,ub as integer		  dim v2 as double		  		  if movie = nil then return		  		  		  v2 = value		  if v2>0 then v2 = v2 + 1/framerate/2.0		  		  ub = ubound(interestingpoints)		  for i = 0 to ub		    if interestingpoints(i) > v2 then		      interestingpoints.insert i, v2		      return		    elseif interestingpoints(i) = v2 then		      return // do not add		    end		  next		  interestingpoints.append v2		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearInterestingPoints()		  if movie = nil then return		  redim interestingpoints(-1)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetCurrentPicture() As picture		  dim p as picture		  		  #if kMBSused		    if movie <> nil then p = movie.MoviePictureMBS(me.position)		  #endif		  		  return p		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Jog(offset as integer)		  dim p, ss, sl as double		  if movie = nil then return		  		  p = self.Position		  		  if offset = 1 or offset = -1 then		    		    self.PlaySelection = true		    if offset<0 then		      self.Position = self.Position-1/framerate		    end		    self.SelStart = self.Position		    if offset<0 then		      self.SelLength = (abs(offset)-0.1)/framerate		    else		      self.SelLength = (offset+0.1)/framerate		    end		    		    self.play		    self.rate = 1		    		    app.DoEvents(100)		  end		  		  self.Position = p+offset/framerate		  		  positionchangedEvent		  		  'SetPosition self.Position		  		  'p =self.position		  '		  '		  '		  '		  '		  'setposition self.position + offset / framerate		  'if self.position = p and abs(offset) = 1 then		  'setposition self.position +  2 * offset / framerate		  'end		  '		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Keydown(key as string)		  dim i,ub as integer		  dim found as boolean		  		  if movie = nil then return		  		  		  // avid style JKL does interfere with the playback		  if self.rate = 0.25 then		    if keyboard.asyncKeyDown(37) and keyboard.asynckeyDown(40) then		      return		    end		  elseif self.rate = -0.25 then		    if keyboard.asyncKeyDown(38) and keyboard.asynckeyDown(40) then		      return		    end		  end		  		  // key tester		  //keytester.KeyMsg		  // j = 38		  // l = 37		  // k = 40		  		  		  select case key		  case chr(1)		    stop		    setposition 0		  case chr(4)		    stop		    setposition duration		  case chr(28)  // right		    if keyboard.asyncshiftKey then		      jog -10		    else		      jog -1		    end		    stop		  case chr(29) // left		    if keyboard.asyncshiftKey then		      jog  10		    else		      jog  1		    end		    stop		  case chr(30)		    wavevolume = 2 * wavevolume		    setwaveform		  case chr(31)		    wavevolume = wavevolume / 2.0		    setwaveform		  case "a"		    previousEdit		  case "s"		    nextedit		  case "d"		    markin 0		  case "f"		    markout 0		  case "g"		    markin 0		    markout 0		  case "i", "e"		    markin self.position		    'setwaveform		  case "j"		    if self.position = self.duration then  // prevent from going to start		      setposition self.position - 1 / framerate		    end 		    if keyboard.asynckeyDown(40) then		      play		      self.rate = -0.25		    else		      if keydelay=0 then		        if self.rate < -0.5 then		          self.rate = 2 * self.rate		        else		          play		          self.rate = -1		        end		        keydelay = 6		      end		    end		  case "k"		    stop		  case "l"		    if keyboard.asynckeyDown(40) then		      play		      self.rate = 0.25		    else		      if keydelay = 0 then		        if self.rate > 0.5 then		          self.rate = 2 * self.rate		        else		          play		          self.rate = 1		        end		        keydelay = 6		      end		    end		  case "o","r"		    markout self.position		    'setwaveform		  case "q"		    setposition inpoint		    stop		  case "w"		    setposition outpoint		    stop		  case " "		    if self.rate <> 0 then		      stop		    else		      play		    end		  else		    keydownevent key		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MarkIn(pos as double)		  inpoint = pos		  markinevent pos		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MarkOut(pos as double)		  outpoint = pos		  markoutevent pos		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub NextEdit()		  dim i,ub as integer		  dim found as boolean		  		  if movie = nil then return		  		  		  found = false		  ub = ubound(interestingpoints)		  for i = 0 to ub		    if interestingpoints(i) > self.position+1.0/framerate then // chang√© 2.0b6 sinon il ne va pas (charles pralong)		      self.position = interestingpoints(i)		      found = true		      exit		    end		  next		  if not found then self.position = self.duration		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub PreviousEdit()		  dim i,ub as integer		  dim found as boolean		  		  if movie = nil then return		  		  		  // find lower interestingpoint		  found = false		  ub = ubound(interestingpoints)		  for i = ub downto 0		    if interestingpoints(i)<>0  and  interestingpoints(i)< self.position-0.5/framerate then		      self.position = interestingpoints(i)		      found = true		      exit		    end		  next		  if not found then self.position = 0		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveInterestingPoint(value as double)		  dim i,ub as integer		  		  if movie = nil then return		  		  		  ub = ubound(interestingpoints)		  for i = 0 to ub		    if interestingpoints(i) = value then		      interestingpoints.remove i		      return		    end		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetPosition(v as double)		  if movie = nil then return		  		  stop		  self.position = v		  		  positionchangedEvent		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetWaveform()		  dim buf,smallbuf as memoryBlock		  dim p,p2 as picture		  dim g as graphics		  dim s,i,j as integer		  dim grid, t as double		  dim pos2,pos1, offset, boff, soff as integer		  dim sz as integer		  dim waveduration, bufwidth,y,dur, maxs as integer		  dim msg as string		  dim movieoffset as integer		  dim rs as integer		  		  		  const kbps = 176400// 44100 * 2 * 2 //stereo, 2 bytes		  samplespersecond = 25		  const kpixelwidth = 600		  maxsound = max(maxsound,1)		  		  if wavevolume = 0 then wavevolume = 1.0 / 1024.0		  		  waveduration = kpixelwidth / samplespersecond		  		  grid = 4		  p = newpicture(600,26,32)		  if movie<>nil then		    // to get consistent waveforms, we always start at entire seconds		    pos1 = self.position		    pos2 =  ( self.position \ waveduration ) * waveduration - waveduration		    pos2 = max(pos2,0)		    offset = samplespersecond * (self.position- pos2)		    		    if waveformcache = nil then waveformcache = new dictionary		    if waveformcache.haskey(pos2) then		      smallbuf = waveformcache.value(pos2)		    else		      // disabled dependency MBS FEATURE MISSING		      #if kMBSused		        dur = min(3 * waveduration, movie.durationMBS-pos2)		      #endif		      if dur>0 and pos2>=0 then		        // disabled dependency MBS FEATURE MISSING		        #if kMBSused		          buf  = movie.soundRawDataMBS(pos2, dur )		        #endif		      end		      		      if buf<>nil then		        sz = buf.size		        bufwidth = 3 * waveduration * samplespersecond 		        smallbuf = newmemoryBlock(2*bufwidth)		        if smallbuf<>nil then		          for i = 0 to bufwidth-1		            s = 0		            for j = 0 to grid-1		              boff = (((1.0 * ( i + j/grid ) / bufwidth )  *  3 * waveduration * kbps)  \ 2 ) * 2		              if boff < sz-1 then  // -1 wg. short 		                s = s +abs(buf.short(boff))		              end		            next		            s = s / grid		            maxsound = max(s,maxsound)		            smallbuf.short(2*i) = s		            maxsound = max(s,maxsound)		          next		          waveformcache.value(pos2) = smallbuf		        end		      else		        msg = "NO SOUND TRACK"		        i = p.graphics.stringwidth(msg)		        p.graphics.drawstring msg, (p.width-i)/2, 15		      end		    end		    		    if smallbuf<>nil then		      g = p.graphics		      for i = 0 to kpixelwidth-1		        soff = i-kpixelwidth/2+offset		        if soff>=0 and soff<smallbuf.size then		          s=smallbuf.short(2*soff) * wavevolume		          s = min(s,11)		          if s>0 then		            g.drawline i,5+8-s-1,i,5+8+s		          else		            g.pixel(i,8+5) = rgb(0,0,0)		          end		        end		      next		    end		    		    		    movieoffset = getoffsetFrames		    g = p.graphics		    for i = 0 to kpixelwidth-1		      t = self.position +  (i-kpixelwidth/2) / samplespersecond		      rs = hastitleevent(t*framerate+movieoffset)		      if rs>=0 then		        if rs>app.readingspeed*1.2 then		          g.pixel(i,0) = rgb(255,0,0)		          g.pixel(i,1) = rgb(255,0,0)		        elseif rs<app.readingspeed*0.8 then		          g.pixel(i,0) = rgb(64,64,255)		          g.pixel(i,1) = rgb(64,64,255)		        else		          g.pixel(i,0) = rgb(64,255,64)		          g.pixel(i,1) = rgb(64,255,64)		        end		      end 		    next		    		    		  end		  waveFormEvent p		  		Exception err as OutOfBoundsException		  MsgBox "OutOfBoundsException in BetterMoviePlayer.SetWaveform"		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Status() As string		  dim s as string		  if movie = nil then 		    return ""		  end		  if self.rate = 0.0 then		    s = "Stop"		  elseif self.rate < 0 then		    s = "< " + format(self.rate*framerate,"0")		  else		    s = format(self.rate*framerate,"0") + " >"		  end		  return s		End Function	#tag EndMethod	#tag Hook, Flags = &h0		Event GetOffsetFrames() As integer	#tag EndHook	#tag Hook, Flags = &h0		Event HasTitleEvent(pos as double) As integer	#tag EndHook	#tag Hook, Flags = &h0		Event KeyDownEvent(key as string)	#tag EndHook	#tag Hook, Flags = &h0		Event MarkInEvent(pos as double)	#tag EndHook	#tag Hook, Flags = &h0		Event MarkOutEvent(pos as double)	#tag EndHook	#tag Hook, Flags = &h0		Event PositionChangedEvent()	#tag EndHook	#tag Hook, Flags = &h0		Event Untitled()	#tag EndHook	#tag Hook, Flags = &h0		Event WaveFormEvent(p as picture)	#tag EndHook	#tag Note, Name = SoundOutputStream		SoundOutputStream Plugin		¬©2003 Mars Saxman		Freeware.				The SoundOutputStream plugin registers one class, also named SoundOutputStream. An instance of this class will play a buffer of sound samples through your system's default audio output device. The class has an interface similar to the built-in REALbasic Sound class:				Class SoundOutputStream 		    Sub Play( buffer As MemoryBlock )		    Sub PlayLooping( buffer As MemoryBlock )		    Sub Stop()		    Function IsPlaying() As Boolean		End Class				SoundOutputStream also has a constructor which requires three parameters:		    sampleRate As Double, stereo As Boolean, sampleType As Integer				These parameters tell the SoundOutputStream what sort of data you intend to provide. The frame rate determines the number of samples per second. The usual value is 44100, or 44.1khz, the sample rate of a compact disc. This means that your source memoryblock will contain 44,100 frames for every second of playback. If you don't care so much about audio quality and would rather save memory, use 22050 instead. This cuts memory use in half, but the sound is a little muddier.				A sound output stream can have one channel (monaural) or two channels (stereo). If you create a mono stream, then one frame is one sample. If you create a stereo stream, then one frame is a Left channel sample followed by a Right channel sample, so your source buffer has to be twice as long for the same playback time.				Finally, there are three possible sample types:		 0 = 32 bit float (Single); values range from -1 to 1		 1 = 16 bit integer; values range from -32768 to 32767		 2 = 32 bit integer; values range from -2 billion to +2 billion				Single-precision samples are most convenient when you are synthesizing audio from wave functions. 16-bit integer samples work well when you are playing back prerecorded audio, which is usually stored on disk in 16-bit integer format. 32-bit integer samples are not as common, but they may be useful if you synthesize or mix sounds and want to use integer math instead of floating-point math.				Once you have created a MemoryBlock full of sounds, call Play or PlayLooping. These work exactly like the Play and PlayLooping methods on REALbasic's Sound class;  Looping mode will play the buffer over and over until you call Stop. 				You can only play one sound per stream at a time. If the stream is already playing a buffer and you call Play or PlayLooping, it will stop the current sound and begin playing the new one instead. To play back more than one channel at a time, create more than one instance of SoundOutputStream.				The SoundOutputStream does not make a separate copy of the MemoryBlock data. Do not resize the MemoryBlock while it is playing. This probably wouldn't cause a crash, but it probably would cause strange, obnoxious, and possibly painful noises to issue from your computer's speakers. It is safe to change the contents of the MemoryBlock while it is being played, however, so long as the size remains constant.					#tag EndNote	#tag Property, Flags = &h0		framerate As double	#tag EndProperty	#tag Property, Flags = &h0		inpoint As double	#tag EndProperty	#tag Property, Flags = &h0		interestingpoints(-1) As double	#tag EndProperty	#tag Property, Flags = &h0		keydelay As integer	#tag EndProperty	#tag Property, Flags = &h21		Private maxsound As integer	#tag EndProperty	#tag Property, Flags = &h0		moviepath As string	#tag EndProperty	#tag Property, Flags = &h0		outpoint As double	#tag EndProperty	#tag Property, Flags = &h0		samplespersecond As integer	#tag EndProperty	#tag Property, Flags = &h0		soundsample As memoryBlock	#tag EndProperty	#tag Property, Flags = &h0		waveformcache As dictionary	#tag EndProperty	#tag Property, Flags = &h0		wavevolume As double	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="AutoDeactivate"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="AutoPlay"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="AutoResize"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Border"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Controller"			Visible=true			Group="Behavior"			InitialValue="2"			Type="Integer"			EditorType="Enum"			InheritedFrom="MoviePlayer"			#tag EnumValues				"0 - None"				"1 - Mini controller"				"2 - Full controller"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="framerate"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="HasStep"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Height"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="HelpTag"			Visible=true			Group="Appearance"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="InitialParent"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="inpoint"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="keydelay"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="LockBottom"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="LockLeft"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="LockRight"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="LockTop"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Looping"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Movie"			Visible=true			Group="Initial State"			Type="Movie"			EditorType="Movie"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="moviepath"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="outpoint"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="Palindrome"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="PlayerType"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			EditorType="Enum"			InheritedFrom="MoviePlayer"			#tag EnumValues				"0 - Preferred player"				"1 - Quicktime"				"2 - Windows Media Player"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="samplespersecond"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Speaker"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="TabIndex"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="TabPanelIndex"			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="TabStop"			Visible=true			Group="Position"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="Visible"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="MoviePlayer"		#tag EndViewProperty		#tag ViewProperty			Name="wavevolume"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="Width"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="MoviePlayer"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass