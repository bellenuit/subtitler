#tag ClassProtected Class RtfParser	#tag Method, Flags = &h0		Sub ApplyStyle(id as integer)		  dim cstylesheet as rtfstylesheet		  dim i as integer		  		  for i = 0 to ubound(stylesheets)		    if stylesheets(i).id = id then		      cstylesheet = stylesheets(i)		      exit		    end		  next		  if cstylesheet = nil then		    return		  end		  		  if cstylesheet.sbasedon <> 222 and cstylesheet.sbasedon <> cstylesheet.id then		    applystyle(cstylesheet.sbasedon)		  end		  cstylesheet.apply me		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  		  encoding = "ansi"		  redim stylesheets(-1)		  state(0) = new rtfstate		  		  //change 1.1 new property newline		  // also replaced all occurences of chr(13) with newline		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DoCommand(command as string, parameter as integer)		  dim i,dummy as integer		  dim d as date		  dim test,dummystring,newline as string		  		  //change 1.1		  #if targetmacOS then		    newline = chr(13)		  #else		    newline = chr(13)+chr(10)		  #endif		  		  		  select case command		    // rtf identification		  case "rtf"		    rtfversion = parameter		    		    // character set		  case "ansi"		    state(0).setencoding command,0		  case "mac"		    state(0).setencoding command,0		  case "pc"		    state(0).setencoding command,0		  case "pca"		    state(0).setencoding command,0		  case "deflang"		    state(0).setencoding command,0		  case "ansicp"		    state(0).setencoding command,parameter		    //new		  case "ansicpg"		    state(0).setencoding command,parameter		    //new		  case "uc"		    state(0).setencoding "unicode",parameter		    //fonts		  case "deff"		    defaultfontid = parameter		  case "fonttbl"		    fonttable = new rtffont		    if not fonttable.parse(input) then		      fonttable = nil		    end		    if fonttable.getfont(defaultfontid)<>"" then		      state(0).font=fonttable.getfont(defaultfontid)		    end		    // stylesheet		  case "stylesheet"		    parsestylesheet		  case "s"		    applystyle parameter		  case "colortbl"		    colortable = new rtfcolor		    if not  colortable.parse(input) then		      colortable = nil		    end		  case "info"		    parseinfo		  case "macpict"		    RtfIgnoreGroup(input)		  case "pmmetafile"		    RtfIgnoreGroup(input)		  case "wmetafile"		    RtfIgnoreGroup(input)		  case "dibitmap"		    RtfIgnoreGroup(input)		  case "wbitmap"		    RtfIgnoreGroup(input)		  case "header"		    // not part of rtf1		    RtfIgnoreGroup(input)		  case "headerl"		    RtfIgnoreGroup(input)		  case "headerr"		    RtfIgnoreGroup(input)		  case "headerf"		    RtfIgnoreGroup(input)		  case "footer"		    // not part of rtf1		    RtfIgnoreGroup(input)		  case "footerl"		    RtfIgnoreGroup(input)		  case "footerr"		    RtfIgnoreGroup(input)		  case "footerf"		    RtfIgnoreGroup(input)		  case "field"		    RtfIgnoreGroup(input)		  case "xe"		    RtfIgnoreGroup(input)		  case "tc"		    RtfIgnoreGroup(input)		  case "object"		    RtfIgnoreGroup(input)		    		    // document formatting properties		  case "deftab"		  case "hyphotz"		  case "linestart"		  case "fracwidth"		  case "makebackup"		  case "defformat"		  case "psover"		  case "deflang"		    // language of the character formatting		  case "ftnsep"		  case "ftnsepc"		  case "ftncn"		  case "endnotes"		  case "enddoc"		  case "ftntj"		  case "ftnbj"		  case "ftnstart"		  case "ftnrestart"		  case "paperw"		    // paper width default 12240 (what unit?)		  case "paperh"		    //		  case "margl"		    //		  case "margr"		    //		  case "margt"		    //		  case "margb"		    //		  case "facingp"		  case  "gutter"		  case "margmirror"		  case "landscape"		    //		  case "pgnstart"		    //		  case "widowctrl"		    		    // revision marks		  case "revisions"		  case "revprop"		  case "revbar"		    		    //section formatting control 		  case "sectd"		    // reset to default section properties		  case "endnhere"		  case "binfsxn"		    // printer bin??		  case "binsxn"		    		    // section break		  case "sbknone"		    // no section break		  case "sbkcol"		  case "sbkpage"		  case "sbkeven"		  case "sbkodd"		    		    // columns in section		  case "cols"		  case "colsx"		  case "linebetcol"		    		    // line numbering		  case "linemod"		  case "linex"		  case "linestarts"		  case "linerestart"		  case "lineppage"		  case "linecont"		    		    // page information		  case "pgwxxn"		    // see here other modell for page size"		  case "pghsxn"		  case "marglsxn"		  case "margrsxn"		  case "margtsxn"		  case "margbsxn"		  case "guttersxn"		  case "lndscpxcsn"		  case "titlepg"		  case "headery"		  case "footery"		    		    // page numbers		  case "pgnstarts"		  case "pgncont"		  case "pgnrestart"		  case "pgnx"		  case "pgny"		  case "pgndec"		  case "pgnucrm"		  case "pgnlcrm"		  case "pgnucltr"		  case "pgnlcltr"		    		    // vertical alignment		  case "vertalt"		    //		  case "vertal"		  case "vertalc"		  case "vertalj"		    		    //paragraph formatting control words		  case "pard"		    // reset to default		    //change 1.1		    state(0).alignment = 1		  case "pardeftab"		    // reset to default		    //change subtitler 1.7.7. for titra3		    state(0).alignment = 1		  case "s"		    // stylesheet		  case "intbl"		  case "keep"		  case "keepn"		  case "noline"		  case "pagebb"		  case "sbys"		    // side by side paragraphs		    		    // alignment		  case "ql"		    //change 1.1		    state(0).alignment = 1		  case "qr"		    //change 1.1		    state(0).alignment = 3		  case "qj"		    //change 1.1		    state(0).alignment = 4		  case "qc"		    //change 1.1		    state(0).alignment = 2		    		    // indentation		  case "fi"		  case "li"		  case "ri"		    		    // spacing		  case "sb"		    // space before		  case "sa"		    // space after		  case "sl"		    // line spacing. if positive then min, else exactly		    // auto = s1000 should be sl1000 or sl000 ??		    		    // tabs		  case "tx"		  case "tqr"		  case "tqc"		  case "tqdec"		  case "tb"		  case "tldot"		  case "tlhyph"		  case "tlul"		  case "tlth"		  case "tleq"		    		    // paragraph borders		  case "brdtp"		  case "brdrb"		  case "brdrl"		  case "brdrr"		  case "brdrbtw"		  case "brdrbar"		  case "box"		  case "brdrs"		  case "brdrth"		  case "brdrsh"		  case "brdrdb"		  case "brdrdot"		  case "brdrhair"		  case "brdrw"		  case "brdrcf"		  case "brdrsp"		    		    // paragraph shading		  case "shading"		  case "bghoriz"		  case "bgvert"		  case "bgfdiag"		  case "bgcross"		  case "bgdcross"		  case "bgdkhoriz"		  case "bgdkvert"		  case "bgkfdiag"		  case "bgbkbdiag"		  case "bgdkdcross"		  case "cfpat"		  case "cbpat"		    		    // position		  case "absw"		  case "absh"		    		    // horizontal position		  case "phmmrg"		  case "phpg"		  case "phcol"		  case "posx"		  case "posxc"		  case "posxi"		  case "posxo"		  case "posxr"		  case "posxl"		    		    // vertical position		  case "pvmrg"		  case "pvpg"		  case "pvpara"		  case "posy"		  case "posyil"		  case "posyt"		  case "posyc"		  case "posyb"		    		    // text wrapping		  case "dxfrtext"		  case "dyfrtext"		    		    // tables		  case "trowd"		  case "trgaph"		  case "cellx"		  case "clmgf"		  case "clmrg"		    		    // cell borders and shadows		  case "clbrdrb"		  case "clbrdrt"		  case "clbrdrl"		  case "clbrdrr"		    		    // row formatting		  case "trql"		  case "trqc"		  case "trleft"		  case "trrh"		    		    // cell shading and background pattern		  case "clshdng"		  case "clbghoriz"		  case "clbgvert"		  case "clbgfdiag"		  case "clbgcross"		  case "clbgdcross"		  case "clbgkhor"		  case "clbgkdcross"		  case "clbgdkhor"		  case "clbgdkvert"		  case "clbgdkfdiag"		  case "clbgdkcross"		  case "clbgdkdcross"		  case "clcfpat"		  case "clcbpat"		    		    // character formatting properties		  case "plain"		    state(0).setplain		  case "b"		    state(0).bold = (parameter=1)		  case "caps"		    state(0).capitals = (parameter=1)		  case "deleted"		  case "dn"		  case "expnd"		    state(0).expanded = parameter/4		  case "f"		    if fonttable <> nil then		      state(0).font=fonttable.getfont(parameter)		      state(0).setencoding "fcharset",fonttable.getcharset(parameter)		    end		  case "fs"		    state(0).textsize = parameter/2		  case "i"		    state(0).italic = (parameter=1)		  case "outl"		    state(0).outline = (parameter=1)		  case "revised"		  case "smcaps"		    state(0).smallcapitals = (parameter=1)		  case "shad"		    state(0).shadow = (parameter=1)		  case "strike"		  case "ul"		    state(0).underline = (parameter=1)		  case "uld"		    state(0).underline = true		  case "uldb"		    state(0).underline = true		  case "ulnone"		    state(0).underline = false		  case "ulw"		    state(0).underline = true		  case "up"		  case "v"		  case "lang"		    		    // ?		  case "cf"		    state(0).foregroundcolor = colortable.getcolor(parameter)		  case "cb"		    state(0).backgroundcolor = colortable.getcolor(parameter)		    		    // special characters		  case "chdate"		    d = new date		    write d.longdate		  case "chdpl"		    d = new date		    write d.longdate		  case "chdpa"		    d = new date		    write d.shortdate		  case "chtime"		    d = new date		    write d.shorttime		  case "chpgn"		  case "chftn"		  case "chatn"		  case "chftnsep"		  case "chftnsepc"		  case "cell"		  case "row"		  case "par"		    //change 1.1		    write newline		  case "sect"		  case "page"		  case "column"		  case "line"		    //change 1.1		    write newline		  case "tab"		    write chr(9) // changed subtitler		  case "emdash"		    write "—"		  case "endash"		    write "–"		  case "bullet"		    write "•"		  case "lquote"		    write "‘"		  case "rquote"		    'write chr(213)		    write "’"		  case "ldblquote"		    write "“"		  case "rdblquote"		    write "”"		  case "l"		    // formula character		  case "~"		    // nonbreaking space		  case "-"		    // optional hyphen		  case "_"		    // nonbreaking hyphen		  case ":"		    // subentry in index		  case "*"		    // text to ignore		    RtfIgnoreGroup(input)		  case "{"		    write command		  case "}"		    write command		  case "\"		    write command		  case "'"		    // 1.2 should be ignored if the last character was unicode, see below		    write state(0).decode(parameter)		  case chr(10)		    //change 1.1		    write newline		  case chr(13)		    //change 1.1		    write newline		  case chr(3)		    //change 1.1		    write newline		  case "u"		    write state(0).decodeunicode(parameter)		     // ignore following special character		    test = input.read(2)		    if test = "\'" then  // reintroduced		      Rtfparsecommand(input,dummystring,dummy)		    else		      input.position(input.position-1)		    end		  case "alt"		  case "shift"		  case "ctrl"		  case "fn"		  else		    'write "UNKNOWN "+command + "-"+parameterstring+chr(13)		    // do nothing		  end		  		  if command <> "u" then // 1.2 correcting double entries		    currenttarget.setstate(state(0).clone)		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Parse(b as binarystream, out as rtftarget)		  dim b2 as ramstream		  b2 = new ramstream(b.length)		  b2.write b.read(b.length)		  b2.position(0)		  parse b2,out		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Parse(t as ramstream, out as RtfTarget)		  dim car,com as string		  dim par, progressstep as integer		  		  input = t		  currenttarget = out		  		  if progress<>nil then		    progress.maximum = 100		  end		  		  progressstep = t.length/100		  		  if not out.preprocess then		    return		  end		  		  		  while not t.eof		    car = t.read(1)		    if userCancelled then		      exit		    end		    if t.position mod progressstep = 0 then		      if progress<>nil then		        progress.value = t.position/progressstep		      end		    end		    select case car		    case "{"		      state.insert 0, state(0).clone		    case "}"		      if ubound(state)>0 then		        state.remove 0		      else		        // final closing brackets		        return		      end		    case "\"		      Rtfparsecommand(input,com,par)		      if com = "bin" then  // ignore binary		        t.position(t.position + par)		      else		        docommand com,par		      end		    case chr(13)		      // CR		    case chr(10)		      // LF		    case chr(3)		      // enter		    else		      write car		    end		  wend		  		  if not out.postprocess then		    return		  end		  		  'test		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Parse(s as string, out as rtftarget)		  dim t as folderitem		  dim b as binarystream		  dim b2 as ramstream		  		  		  b2 = new ramstream(lenb(s))		  if b2<>nil then		    b2.write s		    b2.position(0)		    parse b2,out		  end		  		  return		  		  t = gettemporaryFolderItem		  		  if t<>nil then		    		    b = t.createbinaryFile("TEXT")		    if b<>nil then		      b.write s		      b.position = 0		      parse b, out		    end		  end		  		  b.close		  t.delete		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ParseInfo()		  RtfIgnoreGroup(input)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ParseStylesheet()		  dim com,parstring as string		  dim par as integer		  dim bracket as integer		  dim car as string		  dim i,n as integer		  dim parseleft as boolean		  dim css as rtfstylesheet		  		  bracket = 1		  		  while not input.eof		    car = input.read(1)		    select case car		    case "{"		      css= new rtfstylesheet		      css.parse input		      stylesheets.append css		    case "}"		      bracket = bracket -1		    case chr(13)		    case chr(10)		    end		    if bracket = 0 then		      exit		    end		  wend		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetProgressBar(p as progressbar)		  Progress = p		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Test()		  dim i,j as integer		  dim c as color		  dim newline as string		  		  //change 1.1		  #if targetmacOS then		    newline = chr(13)		  #else		    newline = chr(13)+chr(10)		  #endif		  		  //testing fonttable		  if fonttable <> nil then		    write newline+newline+ "Fonttable"+newline		    for i = 1 to fonttable.count		      write str(fonttable.id(i))+" "+fonttable.family(i)+" " +fonttable.name(i)+newline		    next		  end		  		  // testing colortable		  if colortable <> nil then		    write newline+newline+"Colortable"+newline		    for i = 1 to colortable.count		      c=colortable.getcolor(i)		      write hex2(c.red)+hex2(c.green)+hex2(c.blue)+newline		    next		  end		  		   // testing stylesheettable		  write newline+newline+ "Stylesheets"+newline		  for i = 0 to ubound(stylesheets)		    write str(stylesheets(i).id)+" " + stylesheets(i).label +str(ubound(stylesheets(i).commands))+ newline		    for j = 0 to ubound(stylesheets(i).commands)		      write stylesheets(i).commands(j)+newline		    next		  next		  		  // testing encoding		  write  newline+newline+"Encoding "+encoding		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Version()		  // 1.1 4.2.02 parsing of \chr(10) for OSX, alignment, win32 newline support		  // 1.0a3 9.11.00 no changes in parser		  // 1.0a1 14.10.00		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Write(t as string)		  if currenttarget <> nil then		    currenttarget.write t		  end		End Sub	#tag EndMethod	#tag Note, Name = Version		1.2 ignoring now \' after \u		1.2 27.6.6 added parse string			#tag EndNote	#tag Property, Flags = &h1		Protected carstring As string	#tag EndProperty	#tag Property, Flags = &h0		colortable As rtfcolor	#tag EndProperty	#tag Property, Flags = &h1		Protected currentgroup As string	#tag EndProperty	#tag Property, Flags = &h1		Protected currenttarget As RtfTarget	#tag EndProperty	#tag Property, Flags = &h1		Protected defaultfontid As integer	#tag EndProperty	#tag Property, Flags = &h1		Protected encoding As string	#tag EndProperty	#tag Property, Flags = &h0		fonttable As RTFfont	#tag EndProperty	#tag Property, Flags = &h1		Protected input As ramStream	#tag EndProperty	#tag Property, Flags = &h1		Protected numstring As string	#tag EndProperty	#tag Property, Flags = &h1		Protected output As object	#tag EndProperty	#tag Property, Flags = &h0		progress As progressbar	#tag EndProperty	#tag Property, Flags = &h1		Protected rtfversion As integer	#tag EndProperty	#tag Property, Flags = &h0		state(0) As rtfstate	#tag EndProperty	#tag Property, Flags = &h0		stylesheets(0) As RTFstylesheet	#tag EndProperty	#tag Property, Flags = &h1		Protected wasunicode As boolean	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass